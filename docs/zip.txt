ZIP(1)                                                                  ZIP(1)

NAME
       zip - package and compress (archive) files (v3.1)

SYNOPSIS
       zip  [-aABcdDeEfFghjklLmoqrRSTuvVwXyz!@$] [--longoption ...]  [-b path]
       [-n suffixes] [-t date] [-tt date] [zipfile [file ...]]  [-xi list]

       zipcloak (see separate man page)

       zipnote (see separate man page)

       zipsplit (see separate man page)

       Note:  Command line processing in zip 3.0 and later has been changed to
       support  long options and handle all options and arguments more consis-
       tently.  Some old (zip 2.x) command lines that depend on  command  line
       inconsistencies may no longer work.

DESCRIPTION
       zip  is  a compression and file packaging utility for Unix, VMS, MSDOS,
       OS/2, Windows, Minix, Atari, Macintosh, MVS, z/OS, Amiga,  Acorn  RISC,
       and  other  OS.   It is analogous to a combination of the Unix commands
       tar(1) and compress(1) (or tar(1) and gzip(1)) and is  compatible  with
       PKZIP  (Phil  Katz's  ZIP for MSDOS systems) and other major zip utili-
       ties.

       A companion program (unzip(1)) unpacks zip archives.  The zip and unzip
       programs can work with archives produced by most zip utilities (depend-
       ing on features used) and most unzip utilities can work  with  archives
       produced  by  zip (though some utilities may still not support streamed
       archives yet).  zip supports most features of the zip  standard  up  to
       version  4.6,  and some later features as well.  zip 3.0 and later sup-
       ports the Zip64 extensions of PKZIP 4.5 which allow archives as well as
       files  to exceed the previous 2 GB limit (4 GB in some cases).  zip 3.1
       now supports additional compression methods, including bzip2, LZMA  and
       PPMd.  (See below for more on Zip64 and compression methods.)

       (Note  that PKUNZIP 1.10 cannot extract files produced by PKZIP 2.04 or
       zip 2.0 (or later).  You must use  PKUNZIP  2.04g  or  unzip 5.0p1  (or
       later versions) to extract them.)

       See  the  EXAMPLES  section  at  the bottom of this page for some basic
       examples and typical uses of zip.

       For a brief help page on zip and unzip, run each without specifying any
       parameters  on  the  command line.  Both zip and unzip now also support
       the -hh option to show more detailed help.

   Large archives and Zip64
       zip automatically uses the Zip64 extensions when files larger than 4 GB
       are added to an archive, an archive containing Zip64 entries is updated
       (if the resulting archive still needs Zip64), the size of  the  archive
       will  exceed  4  GB,  or when the number of entries in the archive will
       exceed about 64K.  Zip64 is also used for archives streamed from  stan-
       dard  input  as the size of such archives are not known in advance, but
       the option -fz- can be used to force zip to create PKZIP  2  compatible
       archives  (as long as Zip64 extensions are not needed).  You must use a
       PKZIP 4.5 compatible unzip, such as unzip 6 or later, to extract  files
       using the Zip64 extensions.

   Compression methods
       In  addition  to  the standard Deflate compression (method 8) and Store
       methods, zip 3.1 now  supports  bzip2  (compression  method  12),  LZMA
       (method  14)  and  PPMd  (method  98)  compression  if  the appropriate
       libraries are included when zip is compiled.  .zipx archives  are  sup-
       ported,  except  for  some  compression methods such as WavPack (method
       97), Jpeg (method 96) and XZ (method 95).  Some of these (in particular
       XZ) may be supported by zip in the future.

       Each  compression method has advantages over the others.  For instance,
       Deflate tends to be faster than the other methods (except  Store),  but
       PPMd  tends to compress best in many situations (but can be slow).  See
       the -Z option for more on available compression methods.

       A modern unzip (such as unzip 6.1) is needed to  extract  entries  com-
       pressed with the new methods.  Make sure the destination unzip supports
       the selected compression method before using it.

   Encryption
       In addition to standard Traditional (ZipCrypto) zip  encryption,  which
       is now considered weak by current standards, zip 3.1 now supports rela-
       tively strong AES encryption.  See -Y for more on encryption.

       If AES encryption is included in zip, the following  Encryption  Notice
       applies:

              This  distribution includes cryptographic software.  The country
              in which you currently  reside  may  have  restrictions  on  the
              import, possession, use, and/or re-export to another country, of
              encryption software.   BEFORE  using  any  encryption  software,
              please  check your country's laws, regulations and policies con-
              cerning the import, possession, or use, and re-export of encryp-
              tion    software,   to   see   if   this   is   permitted.   See
              <http://www.wassenaar.org/> for more information.

              The U.S. Government Department of Commerce, Bureau  of  Industry
              and  Security (BIS), has classified this software as Export Com-
              modity Control Number (ECCN) 5D002.C.1, which includes  informa-
              tion  security  software using or performing cryptographic func-
              tions and makes it eligible for export under the License  Excep-
              tion ENC Technology Software Unrestricted (TSU) exception.

   Streamed archives
       Streaming is when zip receives its input from a stream such as stdin or
       a pipe where the size of the input is not known or when zip writes  its
       output  to  a  stream  such as stdout or a pipe where the output is not
       seekable (and so data structures in the archive cannot be updated  once
       the sizes are later known).  A streamed archive is an archive that uses
       data descriptors (a small record after the file data) to store size and
       other  information not known when the processing of a file was started.
       Not all streaming  operations  need  to  create  streamed  archives--it
       depends on zip's ability to determine size and other information before
       the file header is written.  Traditional encryption also  requires  use
       of  data  descriptors  (and  so  the  resulting  archives  are streamed
       archives) due to how zip Traditional encryption is defined (AES encryp-
       tion  does  not have this issue).  (The --etwodd Traditional encryption
       option removes the need for data descriptors at the cost  of  a  second
       pass  through  the  file  data.)  Split archives created with the pause
       option also use data descriptors to allow  the  archive  splits  to  be
       written to write once media (such as optical media) without later seek-
       ing.  Streaming is generally automatic and transparent to the user.

       Streamed archives may not be compatible with some  utilities  as  those
       utilities do not yet know how to read data descriptors.  (Note that the
       latest PKWare published zip standard now includes a description of  the
       data  descriptor  format  zip  uses.)  Other utilities do support these
       archives, however.  If you run into problems, zip  provides  a  way  to
       strip  data  descriptors  from  an  existing  archive  using the --copy
       option.  (Zip Traditional encryption relies on  data  descriptors.   If
       Zip Traditional encryption was used, zipcloak can be used to remove the
       encryption first.  AES encryption does not need data descriptors.)

       zip 3.1 now can generate archives that a compatible  stream  unzip  can
       use to fully extract files on the fly, including file attributes.  This
       new mode adds needed information to  the  local  file  entries  in  the
       archive.   Use  -st  to  enable this mode.  This mode may be enabled by
       default by the time zip 3.1 is released.

   MSDOS/Windows drive letters
       If input paths include drive letters, zip will strip the  drive  letter
       when  making the path relative (as required by the zip standard).  This
       can create conflicts if two drives are being zipped  and  both  include
       some  of  the  same  paths.   If  two  or  more drive letters are to be
       included in an archive, -pp or -pa can be  used  to  add  a  prefix  to
       paths,  such as "-pa c/" to add "c/" to the start of each path from the
       C: drive.  Each drive should probably be added  using  a  separate  zip
       operation so that paths from each drive can be properly prefixed.

   Mac OS X
       Though  previous  Mac  versions  had  their  own zip port, zip supports
       Mac OS X as part of the Unix port and most Unix features apply.  Refer-
       ences to "MacOS" below generally refer to Mac OS versions older than OS
       X.  Mac OS X features supported by the  Unix  port,  such  as  resource
       forks via AppleDouble, are identified as UNIX APPLE features.

   Option Summary
       Below is a quick summary of zip options.  See the OPTIONS section below
       for details.  Before using an option you are not familiar with, do read
       the  details  first  as the short descriptions below leave out many key
       details.

       -----------------------------------------------------------------------
       Sh | Long               |  Description
       -----------------------------------------------------------------------
       a  | ascii              | [EBCDIC] Convert EBCDIC text to ASCII.
       aa | all-ascii          | [EBCDIC] Same as -a, but convert all files.
       A  | adjust-sfx         | Adjust offsets in self-extracting archive.
       AC | archive-clear      | [WIN32] Clear archive bits.
       AF | argfiles           | Enable/disable argfile processing.
       -----------------------------------------------------------------------
       AS | archive-set        | [WIN32] Only files with archive bit set.
       ad | ad-sort            | Sort AppleDouble files.
       as | sequester          | [Unix Apple] Sequester AppleDouble files.
       B  | binary             | [VM/CMS, MVS] Force file to be read binary.
       B  |                    | [TANDEM] Set Edit/Enscribe formatting.
       -----------------------------------------------------------------------
       b  | temp-path          | Set directory used for temp file.
       BC | backup-control     | Set directory of backup control file.
       BD | backup-dir         | Set backup directory.
       BF | binary-full-check  | Check entire text file for binary.
       BL | backup-log         | Set path where backup log written to.
       -----------------------------------------------------------------------
       BN | backup-name        | Set name of backup.
       BT | backup-type        | Set type of backup (FULL, DIFF, or INCR).
       c  | entry-comments     | Add/edit comments for each file/entry.
       cd | current-directory  | Set current (zip root) directory.
       C  | preserve-case      | [VMS] Preserve all case on VMS.
       -----------------------------------------------------------------------
       C2 | preserve-case-2    | [VMS] Preserve ODS2 case on VMS.
       C5 | preserve-case-5    | [VMS] Preserve ODS5 case on VMS.
       Cl | case-lower         | Convert names of added/updated to lowercase.
       Cu | case-upper         | Convert names of added/updated to uppercase.
       d  | delete             | Remove (delete) entries from existing archive.
       -----------------------------------------------------------------------
       db | display-bytes      | Display bytes zipped and to go.
       dc | display-counts     | Display count of entries zipped and to go.
       dd | display-dots       | Display progress dots.  Set by -ds.
       de | display-est-to-go  | Display estimate of time to go.
       df | datafork           | [MacOS, UNIX APPLE] Only data forks.
       -----------------------------------------------------------------------
       dg | display-globaldots | Display global progress dots.
       dr | display-rate       | Display est of rate entries being zipped.
       ds | dot-size           | Turn on dots, set bytes processed per dot.
       dt | display-time       | Display time each entry started.
       du | display-usize      | Display uncompressed size of each entry.
       -----------------------------------------------------------------------
       dv | display-volume     | Display volume (disk number) each entry.
       D  | no-dir-entries     | Do not create entries for directories.
       DF | difference-archive | Include just changes since base archive.
       e  | encrypt            | Encrypt entries, prompt for password.
       et | etwodd             | For Trad encrypt, don't use data descriptors.
       -----------------------------------------------------------------------
       E  | longnames          | [OS/2] Use .LONGNAME extended attr for name.
       f  | freshen            | Update existing entry if OS version newer.
       F  | fix                | Try fix relatively intact archive.
       FF | fixfix             | Try fix archive -F can't fix.
       FI | fifo               | Read content from fifos (named pipes) found,
       -----------------------------------------------------------------------
       FS | filesync           | Synchronize/compare archive with file system.
       fd | force-descriptors  | Force use of data descriptors.  (Debug only.)
       fz | force-zip64        | Force use of Zip64 extensions.
       g  | grow               | Add to (grow) existing archive.
       h  | help               | Display basic help screen.
       -----------------------------------------------------------------------
       hh | more-help          | Display extended (detailed) help.
       i  | include            | Include files that match patterns.
       I  | no-image           | [Acorn RISC OS] Don't scan image files.
       ic | ignore-case        | Ignore case when matching archive entries.
       j  | junk-paths         | Store just file names, not paths.
       -----------------------------------------------------------------------
       jj | absolute-path      | [MacOS] Record full absolute path.
       J  | junk-sfx           | Strip any prepended data (e.g. SFX stub).
       k  | DOS-names          | Attempt convert paths to conform to MSDOS.
       kf | keyfile            | Get part or all of encryption key from file.
       l  | to-crlf            | Convert line ends from Unix to MSDOS/Windows.
       -----------------------------------------------------------------------
       la | log-append         | Append to existing logfile.
       lf | logfile-path       | Open a logfile at the given path.
       lF | log-output         | As -lf, but use output name as log name.
       li | log-info           | Include info messages, like names, in log.
       ll | from-crlf          | Convert line ends from MSDOS/Windows to Unix.
       -----------------------------------------------------------------------
       lu | log-utf8           | Put paths in log as UTF-8.
       L  | license            | Display the license.
       m  | move               | Move files into archive (delete on OS).
       MM | must-match         | All input patterns must match, be readable.
       MV | MVS-mode           | [MVS] Set MVS path translation mode.
       -----------------------------------------------------------------------
       n  | suffixes           | Suffix do not compress/special compress list.
       nw | no-wild            | No (internal) wildcard processing.
       N  | notes              | [Amiga, MacOS] Save filenotes as comments.
       o  | latest-time        | Set archive "last modified" time to latest.
       O  | output-file        | Output archive to new file.
       -----------------------------------------------------------------------
       p  | paths              | Include relative paths (default).
       pa | prefix-add-path    | Prefix paths of added/updated entries.
       pn | non-ansi-password  | Remove only ANSI 7-bit password restriction.
       pp | prefix-path        | Prefix all paths in archive.
       ps | allow-short-pass   | Allow passwords shorter than minimum.
       -----------------------------------------------------------------------
       pt | performance-time   | Time zip operation.
       pu | pswd-to-unzip      | When test, pass password to unzip.
       P  | password           | Provide password on command line.
       q  | quiet              | Quiet mode (less messages, prompts).
       Q  | Q-flag             | [QDOS] Set storage mode.
       -----------------------------------------------------------------------
       r  | recurse-paths      | Recurse each directory path.
       R  | recurse-patterns   | Recurse current directory, match path ends.
       RE | regex              | Enable (internal) [] list matching.
       s  | split-size         | Enable splitting, set split size.
       sb | split-bell         | If splitting using -sp, ring bell when pause.
       -----------------------------------------------------------------------
       sc | show-command       | Show command line as read and exit.
       sd | show-debug         | Show debugging information.
       sf | show-files         | Show files that would be processed.
       sF | sf-params          | Add information to -sf listing.
       si | show-pid           | Show pid of zip process.
       -----------------------------------------------------------------------
       so | show-options       | Show available options as compiled.
       sp | split-pause        | Pause between splits (-s) to change media.
       ss | show-suffixes      | Show current settings of suffixes (-n).
       st | stream             | Enable stream mode, allowing stream extract.
       su | show-unicode       | As -sf, but also include UTF-8 paths.
       -----------------------------------------------------------------------
       sU | show-just-unicode  | As -su, but only show UTF-8 paths.
       sv | split-verbose      | Be verbose about splitting.
       S  | system-hidden      | [MSDOS, OS/2, ATARI] Include system/hidden.
       S  | system-hidden      | [MacOS] Include finder files.
       SI | rename-stdin       | Rename stdin "-" archive entry.
       -----------------------------------------------------------------------
       t  | from-date          | Include files modified on or after date.
       tt | before-date        | Include files modified before date.
       T  | test               | Test archive using unzip.
       TT | test-command       | Set command used with -T to test archive.
       TU | unzip-path         | Set path to unzip to test archive with.
       -----------------------------------------------------------------------
       TV | unzip-verbose      | When testing with -T and unzip, be verbose.
       u  | update             | Update entries if OS file newer, and add new.
       U  | copy-entries       | Copy entries from one archive to another.
       UN | unicode            | Set various Unicode settings.
       UT | utest              | Perform Unicode tests.  (Currently disabled.)
       -----------------------------------------------------------------------
       v  | verbose            | Display additional diagnostic information.
       v  | version            | Display compile and version information.
       vq | quick-version      | Display short version information.
       V  | VMS-portable       | [VMS] Save VMS file attributes.
       VV | VMS-specific       | [VMS] As -V, but also save all file blocks.
       -----------------------------------------------------------------------
       w  | VMS-versions       | [VMS] Include file version numbers in names.
       wl | windows-long-paths | [WIN32] Include paths > 260 chars in archive.
       ww | VMS-dot-versions   | [VMS] Like -w, but use "." for numbers.
       ws | wild-stop-dirs     | Wildcards don't cross directory boundaries.
       x  | exclude            | Exclude paths that match files/patterns.
       -----------------------------------------------------------------------
       X  | no-extra           | Exclude all but essential extra fields.
       y  | symlinks           | [UNIX, WIN32] Store symlinks, don't follow.
       yy | mount-points       | [WIN32] Don't follow mount points.
       Y  | encryption-method  | Enable encryption and set encryption method.
       z  | archive-comment    | Set zip file comment.
       -----------------------------------------------------------------------
       Z  | compression-method | Set default compression method.
       0-9|                    | Set compression level.
       !  | use-privileges     | [WIN32] Use privileges (if granted).
       @  | names-stdin        | Get list of input files from stdin.
       @@ | names-files        | Get list of input files from file.
       -----------------------------------------------------------------------
       $  | volume-label       | Include volume label of first file.
       -----------------------------------------------------------------------

       Additional information on how zip operates is sometimes included in
       the details.  For instance, details on how Windows reparse points are
       handled are included under the -yy option.

USE
       The program is useful for packaging a set of  files  for  distribution;
       for archiving files; and for saving disk space by temporarily compress-
       ing unused files or directories.

       The zip program puts one or more compressed files  into  a  single  zip
       archive, along with information about the files (name, path, date, time
       of last modification, protection, and check information to verify  file
       integrity).   An  entire  directory  structure can be packed into a zip
       archive with a single command.  Compression ratios of 2:1  to  3:1  are
       common  for  text  files.   zip  has  one  standard  compression method
       (Deflate) and can also store files without compression.  (In  addition,
       zip 3.1  supports  compression methods bzip2, LZMA, and PPMd.)  See the
       -Z option below for more on compression methods.

       In some cases (typically for very  small  files  or  random  data),  an
       attempt  to  compress  a file may actually increase its size (by a lit-
       tle).  When this happens for the Deflate,  Bzip2  or  PPMd  compression
       methods  (but currently not for LZMA), zip automatically reverts to the
       Store method for that file.

   Command format
       The basic command format is

              zip options archive inpath inpath ...

       where archive is a new or existing zip archive and inpath is  a  direc-
       tory  or file path optionally including wildcards.  When archive is the
       name of an existing zip archive, zip  will  replace  identically  named
       entries  in  the  zip archive (matching the relative names as stored in
       the archive) or add entries for new names.   For  example,  if  foo.zip
       exists and contains foo/file1 and foo/file2, and the directory foo con-
       tains the files foo/file1 and foo/file3, then:

              zip -r foo.zip foo

       or more concisely

              zip -r foo foo

       will replace foo/file1 in foo.zip and add foo/file3 to foo.zip.   After
       this,  foo.zip  contains  foo/file1,  foo/file2,  and  foo/file3,  with
       foo/file2 unchanged from before.

       So if before the zip command is executed foo.zip has:

               foo/file1 foo/file2

       and directory foo has:

               file1 file3

       then after the command foo.zip will have:

               foo/file1 foo/file2 foo/file3

       where foo/file1 is replaced and foo/file3 is new.

   -@ and -@@ File Lists
       If a file list is specified as -@ [Not on MacOS], zip takes the list of
       input  files from standard input instead of from the command line.  For
       example,

              zip -@ foo

       will store the files listed one per line on stdin in foo.zip.  (zip 3.1
       now  strips  leading and trailing white space from paths read by -@ and
       -@@.  White space (such as spaces)  in  the  middle  of  names  is  not
       affected.   To  prevent  this  stripping,  put double quotes around the
       name.)

       Under Unix, this option can be used to powerful effect  in  conjunction
       with  the  find  (1) command.  For example, to archive all the C source
       files in the current directory and its subdirectories:

              find . -name "*.[ch]" -print | zip source -@

       (note that the pattern must be quoted to keep the shell from  expanding
       it).

       (zip can perform this same operation without find:

              zip source . -r -RE -i "*.[ch]"

       where -RE enables regular expression matching.)

       zip  now  also supports -@@ filename, which acts like -@, but reads the
       list of input files from file filename instead of stdin, one  name  per
       line.

   Argument Files (@argfile)
       Argument  files  (argfiles)  are  text  files that contain command line
       arguments for zip.  zip 3.1 supports argument files.   To  include  the
       contents  of  an  argfile in the zip command line, include the argument
       @filename (no space between @ and filename) at the position in the com-
       mand  line  the  args  are to go.  zip opens file filename, reads white
       space separated arguments and inserts them into the command line.   The
       default  file  extension  of  zip argfiles is .zag.  So the contents of
       argfile myargs.zag can be included using @myargs.

       For example, if myargs.txt contains:

               file1.txt  file2.txt

       the command line:

              zip  archive  @myargs.txt

       would create the zip command line:

              zip  archive  file1.txt  file2.txt

       In an argfile, empty lines or lines with just white space  are  consid-
       ered comment lines.  In addition, an argument that is just "#" starts a
       comment that goes to the end of the line.  (No non-space characters can
       be next to the "#".)  For instance, if myopts.zag contains:

              #  myopts.zag
              #  my favorite options
                -3   -lF    #  compression level 3, create logfile

       then the command line:

              zip  @myopts  archive  @myargs.txt

       would result in the command line:

              zip  -3  -lF  archive  file1.txt  file2.txt

       Argfiles  can  include argfiles to a depth of 4, so we can package this
       command as commandline.zag:

              @myopts  archive  @myargs.txt

       and the command line:

              zip  @commandline

       creates the same command line as above:

              zip  -3  -lF  archive  file1.txt  file2.txt

       Use the -sc option to see the resulting command line without  executing
       it:

              zip  @commandline -sc

       displays

              command line:
               'zip'  '-3'  '-lF'  '-sc'  'archive'  'file1.txt'  'file2.txt'

       Argfiles  can  also contain directives.  A directive starts at the left
       edge (excluding white space) and is an argument in the form #directive.
       Currently  the only directive is #echo, which echos what follows to the
       console/message stream.  So if argfile myfiles.zag has the line:

                #echo  I'm here in the argfile

       then the message "myfiles.zag : I'm here in the argfile"  will  display
       when  zip parses this line.  #echo can be useful when debugging complex
       argfiles.

       Option -AF- can be used to turn off processing argfiles,  so  @args.txt
       becomes  just  another file.  -AF- must appear before any argfile argu-
       ments on the command line.

   Streaming input and output
       zip will also accept a single dash ("-") as the zip file name, in which
       case it will write the zip file to standard output, allowing the output
       to be piped to another program. For example:

              zip -r - . | dd of=/dev/nrst0 obs=16k

       would write the zip output directly to a tape with the specified  block
       size for the purpose of backing up the current directory.

       zip  also  accepts a single dash ("-") as the name of a file to be com-
       pressed, in which case it will  read  the  file  from  standard  input,
       allowing zip to take input from another program. For example:

              tar cf - . | zip backup -

       would compress the output of the tar command for the purpose of backing
       up the current directory. This generally  produces  better  compression
       than  the  previous  example  using  the -r option because zip can take
       advantage of redundancy between files. The backup can be restored using
       the command

              unzip -p backup | tar xf -

       When  no  zip file name is given and stdout is not a terminal, zip acts
       as a filter, compressing standard input to standard output.  For  exam-
       ple,

              tar cf - . | zip | dd of=/dev/nrst0 obs=16k

       is equivalent to

              tar cf - . | zip - - | dd of=/dev/nrst0 obs=16k

       zip  archives  created in this manner can be extracted with the program
       funzip which is provided in the unzip package, or by  gunzip  which  is
       provided  in  the gzip package (but some gunzip may not support this if
       zip used the Zip64 extensions). For example:

              dd if=/dev/nrst0  ibs=16k | funzip | tar xvf -

       The stream can also be saved to a file and unzip used.

       (Note that funzip  only  extracts  the  first  entry  in  the  streamed
       archive.   The current unzip 6.1 beta provides preliminary input stream
       support.  By release of unzip 6.1, it should be possible to  use  unzip
       instead of funzip.)

       If  Zip64  support  for  large files and archives is enabled and zip is
       used as a filter, zip creates a Zip64 archive that requires a PKZIP 4.5
       or  later compatible unzip to read it.  This is to avoid amgibuities in
       the zip file structure as defined in the current zip  standard  (PKWARE
       AppNote)  where  the decision to use Zip64 needs to be made before data
       is written for the entry, but for a stream the size of the data is  not
       known at that point.  If the data is known to be smaller than 4 GB, the
       option -fz- can be used to prevent use of Zip64, but zip will exit with
       an  error if Zip64 was in fact needed.  zip 3 and unzip 6 and later can
       read archives with Zip64 entries.  Also, zip removes the  Zip64  exten-
       sions  if  not  needed  when  archive  entries  are  copied (see the -U
       (--copy) option).  zip 3.1 now handles entries near 4 GiB  more  grace-
       fully,  only  using Zip64 when actually needed.  However, if both input
       and output are streamed, Zip64 can't  be  avoided  (but  still  can  be
       turned off using -fz-).

       When directing the output to another file, note that all options should
       be before the redirection including -x.  For example:

              zip archive "*.h" "*.c" -x donotinclude.h orthis.h > tofile

   Zip files
       When changing an existing zip archive, zip will write a temporary  file
       with the new contents, and only replace the old one when the process of
       creating the new version has been completed without error.  (An  excep-
       tion is the -g (--grow) option, which appends to the original archive.)

       If the name of the zip archive  does  not  contain  an  extension,  the
       extension  .zip  is  added.  If  the name already contains an extension
       other than .zip, the existing extension is  kept  unchanged.   However,
       split  archives  (archives  split over multiple files) require the .zip
       extension on the last split.

   Scanning and reading files
       When zip starts, it scans for files to process (if  needed).   If  this
       scan  takes  longer  than about 5 seconds, zip will display a "Scanning
       files" message and start displaying progress dots every  2  seconds  or
       every  so  many entries processed, whichever takes longer.  If there is
       more than 2 seconds between dots it could indicate  that  finding  each
       file  is taking time and could mean a slow network connection for exam-
       ple.  (Actually the initial file scan is a two-step process  where  the
       directory  scan is followed by a sort and these two steps are separated
       with a space in the dots.  If updating an  existing  archive,  a  space
       also  appears  between  the  existing file scan and the new file scan.)
       The scanning files dots are not controlled by the -ds dot size  option,
       but the dots are turned off by the -q quiet option.  The -sf show files
       option can be used to scan for files and get the list of files  scanned
       without actually processing them.

       If  zip  is not able to read a file, it issues a warning but continues.
       See the -MM option below for more on how zip handles patterns that  are
       not  matched  and  files  that  are  not  readable.  If some files were
       skipped, a warning is issued at the end of the zip operation noting how
       many files were read and how many skipped.

   Command modes
       zip  now  supports  two  distinct  types of command modes, external and
       internal.  The external modes (add, freshen,  and  update)  read  files
       from  the  file  system (as well as from an existing archive) while the
       internal modes (copy and delete) operate exclusively on entries  in  an
       existing archive.

       External modes:

       add
              Update  existing entries and add new files.  If the archive does
              not exist create it.  This is the default mode.

       freshen (-f)
              Update existing entries of an archive if newer on the file  sys-
              tem.  Does not add new files to the archive.

       update (-u)
              Update  existing entries if newer on the file system and add new
              files.  If the archive does not exist, issue a warning and  then
              create a new archive.

       Internal modes:

       copy (-U)
              Select  entries  in  an  existing archive and copy them to a new
              archive.  This new mode is similar to update  but  command  line
              patterns  select  entries  in  the  existing archive rather than
              files from the file system and it uses the --out option to write
              the  resulting  archive  to  a  new  file rather than update the
              existing archive, leaving the original archive unchanged.

       delete (-d)
              Select entries in an existing  archive  and  delete  them.   For
              backward   compatibility  this  deletes  entries  in  the  input
              archive, but delete can be used with --out to create a  copy  of
              the  input  archive  with  the  files deleted, leaving the input
              archive unchanged.  When used with --out, delete  and  copy  are
              opposites,  where delete copies the files that copy doesn't, and
              vice versa.

       The new File Sync option (-FS) is also considered a new mode, though it
       is  similar  to  update.   This  mode synchronizes the archive with the
       files on the OS, only replacing files in the archive if the  file  time
       or  size  of  the  OS file is different, adding new files, and deleting
       entries from the archive where there is no matching file.  As this mode
       can  delete  entries from the archive, consider making a backup copy of
       the archive first.

       Also see -DF for creating difference  archives  and  -BT  for  creating
       backup sets.

       See  each option description below for details and the EXAMPLES section
       below for examples.

   Split archives
       zip version 3.0 and later can create split archives.  A  split  archive
       is  a standard zip archive split over multiple files.  (Note that split
       archives are not just archives split into pieces,  as  the  offsets  of
       entries  are  now  based on the start of each split.  Concatenating the
       pieces together will invalidate these offsets, but  unzip  can  usually
       deal  with  it.   zip  will  usually  refuse  to process such a spliced
       archive unless the -FF fix option is used to fix the offsets.)

       One use of split archives is storing a large archive on multiple remov-
       able media.  For a split archive with 20 split files the files are typ-
       ically  named  (replace  ARCHIVE  with  the  name  of   your   archive)
       ARCHIVE.z01, ARCHIVE.z02, ..., ARCHIVE.z19, ARCHIVE.zip.  Note that the
       last file is the .zip file.  In  contrast,  spanned  archives  are  the
       original multi-disk archive format generally requiring floppy disks and
       using volume labels to store disk numbers.  zip supports split archives
       but  not  spanned  archives,  though  a procedure exists for converting
       split archives of the right size to spanned archives.  The  reverse  is
       also  true, where each file of a spanned archive can be copied in order
       to files with the above names to create a split archive.

       Use -s to set the split size and create a split archive.  The  size  is
       given  as  a  number  followed optionally by one of k (kiB), m (MiB), g
       (GiB), t (TiB), or p (PiB) (the default is m).  The -sp option  can  be
       used to pause zip between splits to allow changing removable media, for
       example, but read the descriptions and warnings for  both  -s  and  -sp
       below.

       Though  zip does not update split archives, zip provides the new option
       -O (--output-file or --out) to allow split archives to be  updated  and
       saved in a new archive.  For example,

              zip inarchive.zip foo.c bar.c --out outarchive.zip

       reads  archive  inarchive.zip,  even if split, adds the files foo.c and
       bar.c, and writes the resulting archive to  outarchive.zip.   If  inar-
       chive.zip is split then outarchive.zip defaults to the same split size.
       Be aware that if outarchive.zip and any split files  that  are  created
       with  it  already exist, these are always overwritten as needed without
       warning.  This may be changed in the future.

       unzip 6.00 and earlier do not read split archives.  One  workaround  is
       to  use  -s-  to  convert a split archive to a single file archive that
       unzip 6.00 can read.  Another is to use zipsplit to convert  the  split
       archive to a set of separate archives unzip can read as a group.  unzip
       6.1 can read split archives.

   Unicode
       Though the zip standard requires storing file names/paths in an archive
       using  a  specific character set, in practice zips have stored paths in
       archives in whatever the local  character  set  is.   This  facilitates
       local  use  of  these archives, but creates problems when an archive is
       created or updated  on  a  system  using  one  character  set  is  then
       extracted on another system using a different character set.  When com-
       piled with Unicode support enabled, zip 3.0 stores, in addition to  the
       standard  local  path for backward compatibility, the UTF-8 translation
       of the path.  This provides a common universal character set for  stor-
       ing  paths  that allows these paths to be fully extracted on other sys-
       tems that support Unicode and to match as closely as possible the orig-
       inal path on systems that don't.

       However,  since  zip  3.0  was released, the zip community has moved to
       UTF-8 as the primary character set for storing paths in  archives.   As
       such,  the  default  for  zip 3.1 is to store UTF-8 only.  The previous
       mode of storing local  and  UTF-8  is  available  using  the  -UN=local
       option.   (Entries  made  with either should be accepted by most modern
       unzips.)  Let us know if this change causes any issues.

       For full Unicode support on Linux and similar Unix systems,  make  sure
       you are using a UTF-8 locale.  The locale command should show something
       like "your_language.UTF-8", for example "en_US.UTF-8".  A UTF-8  native
       locale is needed for zip to naturally work with multiple languages.  If
       you  are  using  a  local  locale,  such   as   "en_US"   (instead   of
       "en_US.UTF-8"), zip will detect this and issue Unicode escape sequences
       (such as #U1234 or #L123456, where the number is the hex  code  of  the
       Unicode  character)  instead  of  characters  not in your current local
       character set.  Using a native UTF-8 locale makes working with multiple
       languages much easier and natural.

       On systems (such as Win32) where paths are internally stored as Unicode
       but displayed in the local character set (Windows code page), it's pos-
       sible  that  some  paths  will  be skipped during a local character set
       directory scan.  zip with Unicode file scan support now  can  read  and
       store these paths.  Note that Win 9x systems and FAT file systems don't
       fully support Unicode.

       Be aware that console windows on Win32 and Unix, for example, sometimes
       don't  accurately  show all characters due to how each operating system
       switches in character sets for display.  However, directory  navigation
       tools should show the correct paths if the needed fonts are loaded.

   Windows long paths
       The maximum path length fully supported on Windows systems is generally
       260 bytes.  Longer paths can be created programmatically, however.   In
       the  past  zip  could  not  read  these  longer paths and skipped them.
       zip 3.1 can now read and store these  paths  and  files.   However,  an
       unzip that can handle long paths is needed to restore such entries.  In
       particular, Windows Explorer (as of Windows 7) will generally refuse to
       read  archives that contain long paths.  (7-Zip, for instance, can han-
       dle these long paths.)

       That said, we have made including Windows long paths the default.   The
       user  needs  to ensure long paths are not included in any archive to be
       opened by Windows Explorer or other utilities that  can't  handle  long
       paths.   zip  will warn if a Windows long path is being included.  -wl-
       can be used to leave out long paths.

   Command line format
       zip 3.0 and later use updated command  line  processing  that  includes
       support for long options.

       Short options in an argument take the form

              -s[-][s[-]...][s[-|value|=value| value]]

       where  s  is  a one or two character short option.  A short option that
       takes a value must be last in an argument  and  anything  after  it  is
       taken  as  the value.  If the option can be negated and "-" immediately
       follows the option, the option is negated.  Short options can  also  be
       given as separate arguments

              -s[-|value|=value| value] -s[-|value|=value| value] ...

       Short  options  in general take values either as part of the same argu-
       ment or as the following argument.  An optional =  is  also  supported.
       So

              -tt12071991

       and

              -tt=12071991

       and

              -tt 12071991

       all  work  to set the before date to 1991-12-07.  The -x and -i options
       accept lists of values and use a slightly  different  format  described
       below.  See the -x and -i options.

       Long options take the form

              --longoption[-|=value| value]

       where  the  option  starts  with  "--",  has a multicharacter name, can
       include a trailing dash to negate the option (if  the  option  supports
       it),  and  can have a value (option argument) specified by preceding it
       with = (no spaces).  Values can also be given as  the  following  argu-
       ment.  So

              --before-date=12071991

       and

              --before-date 12071991

       both work.

       Long option names can be shortened to the shortest unique abbreviation.
       See the option descriptions below for which support long  options.   To
       avoid confusion, avoid abbreviating a negatable option with an embedded
       dash ("-") at the dash if you plan to negate it (the parser would  con-
       sider  a  trailing  dash,  such  as  for the option --some-option using
       --some- as the option, as part of  the  name  rather  than  a  negating
       dash).   This  may  be  changed to force the last dash in --some- to be
       negating in the future.

       As of zip 3.1 the forms

              -s = value

       and

              --longoption = value

       are also excepted.  Any white space between the "=" and the  option  or
       value is ignored.

       Some options support optional values.  An optional value must include a
       preceding "="; this is done to avoid ambiguities.  For example:

              -BL

       enables backup logging using the default backup log directory, while

              -BL=backuplogdir

       also enables backup logging but sets the backup log directory to backu-
       plogdir.

   Unix shell processing
       On  Unix,  zip 3.0 and earlier relied on shell globbing to expand wild-
       cards on the command line.  So given

              zip  foo  *.[ch]  -i "test*"

       zip would receive all file names ending with .c and .h from  the  shell
       instead  of the wildcard expression *.[ch], and then would filter those
       names to find any starting with test internally.  (Filters, such as -i,
       -x  and  -R  have  always  required  escaping or quoting to avoid shell
       expansion.)  However, escaping input files, as in:

              zip  foo  "*.[ch]"  -i "test*"

       would not work on Unix as *.[ch] would be handled  as  a  literal  file
       name  and  the  wildcards would not be processed.  (This works on other
       ports, such as Windows, that perform internal wildcard handling.   Just
       not on Unix.)

       zip  3.1  now internally processes wildcards in input file names so the
       results with and without quotes should be the same.   This  now  allows
       file names with spaces and wildcards to be properly processed:

              zip  foo  --RE  "file name with spaces*.[ch]"

       (--RE is needed to enable [] list matching.)

       To include *.[ch] in foo as a literal file name, -- can be used:

              zip  foo  --  "*.[ch]"

       All  wildcard  processing  is  disabled after -- is seen on the command
       line, these arguments taken as verbatim.  For example:

              zip  foo  --  -file  @justafile  "file*with?wildcards"

       will include these files in foo.  Any shell wildcards or special  char-
       acters still need to be escaped or quoted to avoid shell processing.

   Time zones
       As  many operations, such as -f and -u, compare file times to determine
       if a file has changed, it's important for these commands that the  time
       be  consistent between zip operations.  Part of this is making sure the
       proper time zone is set.

       See the -f option for more on time zones.

OPTIONS
       See the zip extended help (-hh) for a quick  breakdown  of  options  by
       function.

       -a
       --ascii
              [Systems using EBCDIC] Translate contents of text files from the
              EBCDIC character set to the ASCII character set.  zip  needs  to
              detect  the file as text for the conversion to happen, otherwise
              the file is handled as having binary contents and not converted.

              See -ll for more on binary/text detection.

       -aa
       --all-ascii
              [Systems  using EBCDIC] Same as -a, but all files are considered
              text and converted from EBCDIC to ASCII.

       -A
       --adjust-sfx
              Adjust self-extracting executable  archive.   A  self-extracting
              executable  archive  is created by prepending the SFX stub to an
              existing archive. The -A option tells zip to  adjust  the  entry
              offsets  stored in the archive to take into account this "pream-
              ble" data.

              Note: Self-extracting archives for the Amiga are a special case.
              At  present,  only the Amiga port of zip is capable of adjusting
              or updating these without corrupting them. -J  can  be  used  to
              remove the SFX stub if other updates need to be made.

       -AC
       --archive-clear
              [WIN32]   Once  archive  is  created  (and tested if -T is used,
              which is recommended), clear the  archive  bits  of  files  pro-
              cessed.  This option is typically used with -AS.

              WARNING:  Once  the  bits are cleared they are cleared.  You may
              want to use the -sf show files option to store the list of files
              processed  before  performing  the archive operation in case the
              archive operation must be repeated.  Also consider using the -MM
              must match option.  Be sure to check out -DF and -BT as possibly
              better ways to do incremental backups.

       -AF
       --argfiles
              Enable processing argfiles.  An argfile is a text file that con-
              tains  command  line arguments for zip separated by white space.
              Given an argfile with name myargs.txt, the command line:

                     zip @myargs.txt

              results in @myargs.txt being replaced on the command line by the
              arguments in the file.

              Argfiles  are  enabled  by default.  Negating this option, -AF-,
              turns off argfile processing, making  @myargs.txt  just  another
              file  name  on the command line.  -AF or -AF- must appear on the
              command line before any argfiles.

              For more information,  see  the  subsection  on  Argument  Files
              above.

       -AS
       --archive-set
              [WIN32]   Only  include  files  that  have  the archive bit set.
              Directories are not stored when -AS is used, though  by  default
              the paths of entries, including directories, are stored as usual
              and can be used by most unzips to recreate directories.

              The archive bit is set by the operating system when  a  file  is
              modified  and,  if used with -AC, -AS can provide an incremental
              backup capability.  However, other applications can  modify  the
              archive  bit  and  it  may  not be a reliable indicator of which
              files have changed since the last archive  operation.   Alterna-
              tive ways to create incremental backups include using -t and -tt
              to use file dates, though this won't catch old files  copied  to
              directories  being  archived,  and  -DF to create a differential
              archive.  For more serious backup operations, consider -BT.

       -ad
       --ad-sort
              Sort file system AppleDouble "._" files  after  the  files  they
              apparently  go  with.  The default on Unix Apple (Mac OS X) sys-
              tems is to sort AppleDouble "._" files created by zip (to  store
              meta  data)  after  the files they go with.  The -ad option also
              includes any "._" files already on the file system  and  in  the
              target  scope in this sort as if they were generated by zip.  On
              Unix Apple systems this generally has limited  utility,  as  the
              AppleDouble  files  zip generates should contain the latest meta
              data (e.g. resource fork information).

              On systems other than Unix Apple, -ad  allows  storing  apparent
              AppleDouble  files  found  on  the file system within the target
              scope after the files  they  apparently  go  with,  creating  an
              archive  that  allows  unzip  to restore the meta data on a Unix
              Apple system.

              This option supports the scenario where a zip archive is created
              on  a  Unix  Apple system, transferred to another system that is
              not Unix Apple, the files extracted and the data files  updated,
              then  zip  used  to  rearchive  the files for transfer to a Unix
              Apple system.  Using -ad when rearchiving the  files  will  sort
              the  AppleDouble  files  properly  so the resulting archive will
              have readable AppleDouble data on the target Unix Apple  system.

              See -as and -df for more information about AppleDouble.

       -as
       --sequester
              [UNIX  APPLE]   Save AppleDouble resource files in a sequestered
              directory, instead of in the directory where the data fork  file
              is.   By default, on Mac OS X systems zip places the AppleDouble
              "._" files in the same directory as  the  files  they  go  with.
              When  sequestering  is used, the finder and resource information
              get stored in a single __MACOSX/ directory at the  root  of  the
              zip  archive.   (See  -df  for more on how zip saves Mac OS meta
              data.)

       -B
       --binary
              [VM/CMS and MVS] force file to be read binary (default is text).

       -Bn    [TANDEM] set Edit/Enscribe formatting options with n defined as
              bit  0: Don't add delimiter (Edit/Enscribe)
              bit  1: Use LF rather than CR/LF as delimiter (Edit/Enscribe)
              bit  2: Space fill record to maximum record length (Enscribe)
              bit  3: Trim trailing space (Enscribe)
              bit  8: Force 30K (Expand) large read for unstructured files

              Note:  For backward compatibility, this option requires a number
              directly following the -B (no spaces).

       -b path
       --temp-path path
              Use the specified path for the temporary zip archive. For  exam-
              ple:

                     zip -b /tmp stuff *

              will  put the temporary zip archive in the directory /tmp, copy-
              ing over stuff.zip to the  current  directory  when  done.  This
              option  is useful when updating an existing archive and the file
              system containing this old archive does not have enough space to
              hold both old and new archives at the same time.  It may also be
              useful when streaming in some cases to avoid the need  for  data
              descriptors.   Note  that using this option may require zip take
              additional time to copy the archive file when done to the desti-
              nation file system.

       -BC controldir
       --backup-control controldir
              Set  directory  of  backup  control  file.   The name of the zip
              backup control file is given by -BN with _control.zbc  appended.

              Used  with  -BT to create a repeatable backup cycle.  -BC allows
              selecting the location where the backup control file is  written
              and  maintained.   If -BC is not given, -BD is used for the con-
              trol directory instead.  See -BT for more information on setting
              up repeatable backup cycles.

       -BD backupdir
       --backup-dir backupdir
              Set the directory for the backup archive.  Also default location
              of control file and log file unless -BC or -BL are used to set a
              different control file directory or backup log directory.

              Used with -BT to create a repeatable backup cycle.  -BD sets the
              path/directory where the backup archive goes.  The archive  name
              is  given  by  -BN.   See -BT for more information on setting up
              repeatable backup cycles.

       -BF
       --binary-full-check
              Check entire file for binary.   Normally  zip  only  checks  the
              first  couple  buffers for binary and, if not found, the file is
              labeled a text file.  This check is usually very  reliable,  but
              can be wrong if there's binary late in a large file.  -BF forces
              zip to check the entire file.

              -BF is automatically set if -l, -ll, or -a are used so that  the
              text/binary  decision  can be validated and action taken if con-
              versions were done to a binary file.

              See -ll for more on text/binary checks.

       -BL
       -BL=backuplogdir
       --backup-log
       --backup-log=backuplogdir
              Set the path/directory the backup log file is written to.

              -BL is for use with -BT only.  For normal logging,  use  -lf  or
              -lF instead.

              backuplogdir  is optional.  If -BL is given without specifying a
              log directory, the backup directory given by -BD is  used.   The
              name  of the log is the same as the archive, except that .zip is
              replaced by .log.

              Used with -BT to create a repeatable backup cycle.  -BL  enables
              logging  of  repeatable backup cycles and sets the location that
              the log is written to if backuplogdir is provided.  See -BT  for
              more information on setting up repeatable backup cycles.

              Note  that -BT creates date/timestamped archive names and so the
              logfiles will also have date/timestamped names.

       -BN backupname
       --backup-name backupname
              Set the name of the backup.  This name is used for  the  control
              file, archive, and log.

              Used with -BT to create a repeatable backup cycle.  -BD sets the
              directory where the backup archive goes while -BN sets the name.
              To this name is appended timestamp and other information to form
              the actual archive name used for a particular  repeating  backup
              cycle.   See  -BT  for more information on setting up repeatable
              backup cycles.

       -BT backuptype
       --backup-type backuptype
              Set the type of backup being done this cycle.

              Used with -BC, -BD, -BL, and -BN to create a  repeatable  backup
              cycle.   -BT  sets  the  type  of  backup being done this cycle.
              Types include FULL (backup all files within scope), DIFFERENTIAL
              (backup  files  that  are  new  or  changed  since the last FULL
              backup), or INCREMENTAL (backup files that are  new  or  changed
              since  the  last  FULL backup or any DIFFERENTIAL or INCREMENTAL
              backups since then).

              Note that -BT is currently available only on systems  that  sup-
              port long file names.

              zip -BT can be used in a time repeating script, for instance, to
              perform repeatable backup cycles.  One approach is to use  three
              separate  repeating scripts, one to run FULL backups, one to run
              DIFFERENTIAL backups, and one to run INCREMENTAL  backups.   For
              instance, the FULL script might include:

                     zip  -BT  full  -BD  mybackups  -BN foo_backup -BL -li -r
                     foodir

              and run monthly.  The DIFF script might include:

                     zip -BT diff -BD mybackups  -BN  foo_backup  -BL  -li  -r
                     foodir

              and run weekly.  The INCR script might include:

                     zip  -BT  incr  -BD  mybackups  -BN foo_backup -BL -li -r
                     foodir

              and run daily.  -BD puts the backup archives, the logs, and  the
              control file in the mybackups directory.  -BN specifies that the
              archives, logs, and control file will have names  starting  with
              foo_backup.   -BL  -li (options -BL and -li) enables backup log-
              ging and tells zip to include informational  messages  (such  as
              the  files  processed) in the log.  The -r directs zip to backup
              the directory foodir and any subdirectories.  It is  recommended
              that  the  times  these  scripts run be offset so that DIFF runs
              after any INCR is expected to be finished and  FULL  runs  after
              any  DIFF  or INCR is expected to be finished.  Avoid overlap if
              possible to minimize possible  content  inconsistencies  between
              backups.

              Preferrably,  one  script  could be used to run all three backup
              types, this script run on a timed cycle and choosing the  backup
              type based on a schedule.  Since only one script is ever running
              at any particular time, this avoids conflicts between the  types
              of  backups.  If necessary, this script could include a check to
              see if it was still running from a previous backup cycle and, if
              so, postpone the next backup until the current one finished.

              This  mode  of zip creates a control file that is written to the
              backup path specified by -BD (or to the control path if  -BC  is
              used).   The name of the control file is given by -BN with _con-
              trol.zbc appended.  This control file tracks the  archives  cur-
              rently  in  the backup set.  The backup path is also used as the
              destination of the created archives, so  no  output  archive  is
              specified.  Rather this mode creates the output name by adding a
              mode (full, diff, or incr) and a date  and  time  stamp  to  the
              backup  path.   This  allows  recurring  backups to be generated
              without altering the command line to specify new  archive  names
              each cycle to avoid overwriting previous archives and logs.  zip
              does not delete old archives and logs -- the user needs to track
              these and move or delete them as appropriate.

              The backup types are:

                     FULL - Create a normal zip archive that forms the core of
                     the backup set.  Also creates a control  file  that  only
                     lists this one archive.  Any listings of other (differen-
                     tial and incremental) archives from previous backup oper-
                     ations  are removed.  Backup type FULL essentially starts
                     a new backup set.

                     DIFFERENTIAL - Create a --diff archive against  the  FULL
                     archive  listed  in the control file, and update the con-
                     trol file to list both the FULL  and  DIFF  archives.   A
                     DIFF  backup  set  consists of just the FULL and new DIFF
                     archives, as these two archives capture all files (except
                     deletions,  as  noted  below).   Any  other  DIFF or INCR
                     archives are removed from the backup set (the list in the
                     control  file), but are not removed from the file system.

                     INCREMENTAL - Create a --diff archive  against  the  FULL
                     and  any  DIFF  or INCR archives in the control file, and
                     update the control file.  An INCR backup set consists  of
                     the  FULL  archive and any DIFF and INCR archives created
                     to that point.  An INCR  backup  captures  just  new  and
                     changed  files  not  yet included in the backup set.  Any
                     number of INCR archives can be  included  in  the  backup
                     set, each capturing an incremental change in the state of
                     the target.

              A FULL backup clears any DIFF and INCR entries from the  control
              file,  hence  starts a new backup set.  A DIFF backup clears out
              any INCR archives listed in the control file, as  the  FULL  and
              DIFF  are  sufficient  to describe the state of the target scope
              (except as noted below).  An  INCR  backup  just  adds  the  new
              incremental archive to the list of archives in the control file.

              Note that DIFF and INCR backups do not account for  deletion  of
              files  in the target scope.  Only FULL backups account for dele-
              tions.  For this reason, occasional FULL backups should be done.
              We  may  add  a  way to incrementally track deleted files in the
              future.

              All archives listed in the control file must be present  in  the
              backup file location specified or an error will occur.

              For  repeating  backups  to  properly work, the same zip command
              line should be used for all  backups  (FULL,  DIFF,  and  INCR),
              except  for  changing  -BT  to set backup type.  The zip command
              should also be run from the same directory each time to use  the
              same  file  scope.   The  same  control file must be used by all
              backup operations maintaining the same  backup  set  for  proper
              differential  and  incremental operation.  Different backup sets
              use different control files.  To avoid issues,  make  sure  each
              backup  configuration has a unique name as set by -BN.  Multiple
              backup configurations can go in the same directory  as  long  as
              they are uniquely named.

              Full backups will have names such as:

                     mypath/mybackupset_full_FULLDT.zip

              and differentials/incrementals will have names such as:

                     mypath/mybackupset_full_FULLDT_incr_INCRDT.zip

              where  the  name of the full backup the differential/incremental
              goes to is part of the file name.  Above, FULLDT and INCRDT  are
              date-time  stamps  of  the full and incremental backups, respec-
              tively.

              It is recommended that the backup path be  outside  of  what  is
              being  backed up, either a separate drive, path, or other desti-
              nation, or -x is used to exclude the backup path  directory  and
              everything  in  it.   Otherwise  each backup may get included in
              later backups, creating exponential growth.

              If you don't need to track changes over time but simply want  to
              save  the  latest  changes, consider just creating normal (FULL)
              zip archives or using --diff to create FULL and  DIFF  archives.
              The  -u  Update and -FS File Sync options are other alternatives
              to consider.

       -c
       --entry-comments
              Add one-line comments for each entry  (file).   File  operations
              (adding, updating) are done first, and the user is then prompted
              for a one-line comment for each file.  Enter  the  comment  fol-
              lowed by return, or just return for no comment.

              zip  3.1  now  presents  any  existing comment and allows either
              keeping it or replacing it.  zip 3.1 also allows multi-line com-
              ments for entries, but currently few other utilities can display
              or edit them.  Check the target utility for  multi-line  comment
              support before using them.

              When  editing comments of an existing archive, zip will accept a
              list of names and/or filters to choose the entries  to  add/edit
              comments for.  For instance, if the archive foo.zip contains the
              entries a.txt, b.txt, e/c.txt and e/d.txt, to edit just the com-
              ment for c.txt, either

                     zip foo -c e/c.txt

              or

                     zip foo -c -i*c.txt

              could be used.  The result might be:

                     Current comment for e/c.txt:
                      old comment

                     Enter comment for e/c.txt:
                      (ENTER=keep, TAB ENTER=remove, SPACE ENTER=multiline)
                      new comment

              TAB ENTER is hitting TAB followed by ENTER.  SPACE ENTER is hit-
              ting SPACE followed by ENTER.

              Zip will accept UTF-8 comments on ports where  UTF-8  is  native
              (such  as  a  UTF-8 locale on Unix systems).  Currently zip does
              not accept Unicode comments on Windows from the  console.   This
              may be addressed by release of zip 3.1.  Before setting comments
              that are not plain 7-bit ANSI text, check the target  unzip  for
              UTF-8 comment support.

              See zipnote as a way to do batch editing of file comments.

       -cd dir
       --current-directory dir
              Set the current directory to dir before beginning the zip opera-
              tion.  This sets the root of the resulting archive,  i.e.  rela-
              tive  paths  stored in the archive are relative to this location
              in the file system.

              If -q is not used, the directory path changed to  is  displayed.
              As  zip typically runs in a separate process, the change to cur-
              rent directory only impacts zip and not the process or shell  it
              is run from.

              Without -cd, zip generally inherits the current directory of the
              calling process, typically a shell.   -cd  allows  the  relative
              paths  zip  sees  to  be interpreted relative to the new current
              directory dir, while leaving the current directory of the caller
              unchanged.

              On  Windows,  if dir includes a different drive letter, zip will
              change the current drive to that drive.  For instance,

                     C:\foo> zip myarchive test.txt -cd E:\bar

              will look in E:\bar for test.txt and  will  write  myarchive  to
              E:\bar.

              An  alternative to -cd is to change the current directory in the
              calling process before calling zip.

       -C
       --preserve-case
              [VMS]  Preserve all case on VMS.   Negating  this  option  (-C-)
              downcases file names.

       -C2
       --preserve-case-2
              [VMS]   Preserve  ODS2 case on VMS.  Negating this option (-C2-)
              downcases.  Default:  -C2- (downcase ODS2 names).

       -C5
       --preserve-case-5
              [VMS]  Preserve ODS5 case on VMS.  Negating this  option  (-C5-)
              downcases.  Default:  -C5 (preserve case of ODS5 names).

       -Cl
       --case-lower
              Convert added/updated entry path names in output archive to low-
              ercase.

              It is an error to use -Cl and -Cu together.

              Only the paths of added or updated entries are impacted.  If  an
              existing  archive  is  being  updated,  the paths of entries not
              being updated remain unchanged.  If an entry has a Unicode path,
              that is also updated.

              This  option  occurs after VMS name processing and so has prece-
              dence over the -C, -C2 and -C5 options.

              See also -pa and -pp for prefixing paths.

       -Cu
       --case-upper
              Convert added/updated entry path  names  in  output  archive  to
              uppercase.  See -Cl for more information.

       -d
       --delete
              Remove (delete) entries from a zip archive.  For example:

                     zip -d foo  foo/tom/junk  foo/harry/\*  \*.o

              will  remove the entry foo/tom/junk, all of the files that start
              with foo/harry/, and all of the files that end with .o  (in  any
              path).   Note  that  shell pathname expansion has been inhibited
              with backslashes, so that zip can see  the  asterisks,  enabling
              zip  to  match on the contents of the zip archive instead of the
              contents of the current directory.   (The  backslashes  are  not
              used  on  MSDOS-based or VMS platforms.)  Can also use quotes to
              escape the asterisks as in

                     zip -d foo  foo/tom/junk  "foo/harry/*"  "*.o"

              Not escaping the asterisks on a system where the  shell  expands
              wildcards  could  result  in  the asterisks being converted to a
              list of files in the current directory and  that  list  used  to
              delete  entries  from  the  archive, which is likely not what is
              wanted.

              -@ and -@@ can be used to provide zip with a list  of  files  to
              delete.  For example:

                     zip foo -d  -@@filestodelete.txt

              will delete the files in filestodelete.txt, listed one per line,
              from archive foo.zip.  (As of zip 3.1, any leading and  trailing
              white  space  on  each  line is trimmed.  (Embedded white space,
              such as in the name "name with spaces.txt", remains after  trim-
              ming.)   If  a  path  includes  leading or trailing white space,
              enclose  it  in  double   quotes,   as   in   "  name_with_lead-
              ing_white_space.txt".)

              Argfiles can also be used.  For instance:

                     zip foo -d @filestodelete.zag

              will  delete files listed in filestodelete.zag, those file names
              separated by white space.  Unlike -@@, however, file names  that
              include  white  space must be enclosed in double quotes (as they
              would need to be if included on the command line).

              Under MSDOS and Windows, -d is case sensitive  when  it  matches
              names  in  the  zip  archive.   This requires that file names be
              entered in upper case if they were zipped by PKZIP on  an  MSDOS
              system.   (We considered making this case insensitive on systems
              where paths were  case  insensitive,  but  it  is  possible  the
              archive  came  from  a  system  where  case  does matter and the
              archive could include both Bar and bar as separate files in  the
              archive.)   But  see  the  new  option -ic to ignore case in the
              archive.

       -db
       --display-bytes
              Display running byte counts showing the  bytes  zipped  and  the
              bytes to go.

       -dc
       --display-counts
              Display running count of entries zipped and entries to go.

       -dd
       --display-dots
              Display  dots  while  each entry is zipped (except on ports that
              have their own progress indicator).  See -ds below  for  setting
              dot  size.   The default is a dot every 10 MB of input file pro-
              cessed.  The -v option also displays dots (previously at a  much
              higher  rate  than  this  but now -v also defaults to 10 MB) and
              this rate is also controlled by -ds.

       -de
       --display-est-to-go
              Display an estimate of the time to finish the  archiving  opera-
              tion.   The  estimate is based on the calculated rate of bytes /
              second, so the estimated times can vary as  system  loading  and
              execution  speed  change.  (See -dr for more on this.)  zip does
              not display an estimate until enough entries  are  processed  to
              get a reasonable bytes / second rate.

       -df
       --datafork
              [MacOS,  UNIX APPLE] Include only the data-forks of files zipped
              into the archive.   Resource  forks  and  Finder  info  will  be
              ignored.  This is useful when exporting files to foreign operat-
              ing systems where the resource information may  not  be  needed.
              The  MacOS  port (Mac OS before Mac OS X) saves this information
              in extra fields while the Unix Apple (Mac OS X)  port  uses  the
              AppleDouble  format.   (See -as for more on the AppleDouble for-
              mat.)

       -dg
       --display-globaldots
              Display progress dots for the archive instead of for each  file.
              The command

                         zip -qdgds 100m

              will turn off most output except dots every 100 MiB.  On typical
              personal systems in use as of this writing, this simply displays
              a dot every few seconds, providing a low overhead way to monitor
              progress.  If the total number of bytes is  known  (such  as  by
              using  -sf first), the total number of dots expected can be cal-
              culated.  The setting of -ds can be adjusted to get the dot rate
              desired,  for  instance  to 1g to get dots every 1 GiB processed
              which is roughly a dot a minute on the above example systems.

              This can be used with -lFli to store detailed information  in  a
              log  file  while  minimizing console output (which typically can
              slow progress).  As zip flushes the  log  file  as  changes  are
              made, one can open the log on occasion to see how far zip is.

       -dr
       --display-rate
              Display  an  estimate  of  the  rate entries are being zipped in
              bytes / second.  The estimate can vary  as  system  loading  and
              execution  speed  change.  The rate also can change depending on
              the size of the files (writing content is a different rate  than
              writing  meta  data, for instance, so the rate can change as zip
              proceeds through different parts of a directory  tree)  and  the
              amount  of  console  output  (more output generally results in a
              slower rate).  zip does not display a rate estimate until enough
              entries  are  processed  to  get a reasonable rate.  This is the
              rate used by -de.  This option and -de  are  only  available  on
              systems that can provide sufficiently accurate timimg.

       -ds size
       --dot-size size
              Set amount of input file processed for each dot displayed.  Set-
              ting this option implies -dd.  size is in the format nm where  n
              is  a number and m is a multiplier.  Currently m can be k (KiB),
              m (MiB), g (GiB), t (TiB), or p (PiB), so if n is 100 and  m  is
              k,  size would be 100k which is 100 KiB.  The default is 10 MiB.
              A size of 0 turns dots off.

              The -v option also displays dots and now  defaults  to  10  MiB.
              This rate is now controlled by this option.

              This  option does not control the dots from the "Scanning files"
              message as zip scans for input files.  The dot size for that  is
              fixed  at  2  seconds or a fixed number of entries, whichever is
              longer.  Note that if the time between these  scanning  dots  is
              much  greater than 2 seconds, this may indicate a very slow data
              connection, such as a bad network connection.

       -dt
       --display-time
              Display the current time as each entry is started.  This is in a
              day/time  format, where day is the calendar day of the month and
              time is in 24 hour format.

       -du
       --display-usize
              Display the uncompressed size of each entry.  This is  displayed
              in parentheses after the name.

       -dv
       --display-volume
              Display  the volume (disk) number each entry is being read from,
              if reading an existing archive, and being written to.  These are
              the  disk numbers of multi-volume archives (or 1 for single vol-
              ume archives), and are not related to  any  file  system  volume
              names.   This option may be useful when reading or writing split
              (multi-volume) archives.

       -D
       --no-dir-entries
              Do not create  entries  in  the  zip  archive  for  directories.
              Directory   entries   are  created  by  default  so  that  their
              attributes can be saved in the archive.  The  environment  vari-
              able  ZIPOPT  can  be  used  to change the default options.  For
              example, under Unix with sh:

                     ZIPOPT="-D"; export ZIPOPT

              (The variable ZIPOPT can be used for any  option,  including  -i
              and -x using a new option format detailed below, and can include
              several options.)  The option -D is a shorthand for -x "*/"  but
              the  latter previously could not be set as default in the ZIPOPT
              environment variable as the contents  of  ZIPOPT  gets  inserted
              near  the beginning of the command line and the file list had to
              end at the end of the line.

              This version of zip does allow -x and -i options  in  ZIPOPT  if
              the form

               -x  file file ...  @

              is used, where the @ (an argument that is just @) terminates the
              list.

       -DF
       --difference-archive
              Create an archive that contains all new and changed files  since
              the  original  archive was created.  For this to work, the input
              file list and current directory must be the same as  during  the
              original zip operation.

              For example, if the existing archive was created using

                     zip -r foofull .

              from the bar directory, then the command

                     zip -r foofull . -DF --out foonew

              also  from the bar directory creates the archive foonew.zip with
              just the files not in foofull.zip and the files where  the  size
              or file time of the files do not match those in foofull.zip.

              Note  that  the  time zone environment variable TZ should be set
              according to the local time zone in order  for  this  option  to
              work  correctly.   A  change  in  time  zone  since the original
              archive was created could result in no times  matching  and  all
              files being included.  (See -f for more on time zones.)

              A possible approach to backing up a directory might be to create
              a normal archive of the contents of  the  directory  as  a  full
              backup,  then  use  this  option to create differential backups.
              The new compression method CD_ONLY can be used to create a  copy
              of  the normal (full backup) archive that only contains the file
              list data.  This much smaller archive can't be used  to  restore
              files,  but  can  be  used as a base archive to use -DF against,
              allowing the much larger full backup archive to be moved off the
              system  to save space.  (See -Z for more on compression methods,
              including CD_ONLY.)

              To just keep a single zip archive in sync with a directory, con-
              sider -FS.  For more extensive backup operations, take a look at
              -BT.

       -e
       --encrypt
              Encrypt the contents of the zip archive using a  password  which
              is  entered  on the terminal in response to a prompt.  The pass-
              word will not be echoed at the  user's  terminal.   If  standard
              input  (or  /dev/tty  or SYS$COMMAND, depending on the operating
              system) is not a tty, zip will exit with an error.  The password
              is requested twice to save the user from typing errors.

              See -Y for more on the types of encryption zip supports and set-
              ting the encryption method.

       -et
       --etwodd
              When using Traditional zip encryption, zip uses data descriptors
              to   avoid   making  multiple  passes.   The  --etwodd  (encrypt
              traditional without data descriptors) option forces zip to  make
              the multiple passes to avoid the need for data descriptors.  The
              result should be an archive that is  more  generally  compatible
              with other zip utilities.

              Use  of  this  option on a large archive or large file set could
              greatly increase the time needed to  create  an  archive,  maybe
              taking 50% to 100% more time.

              Without  this option, the archives created are backward compati-
              ble, and these archives are generally readable by most utilities
              now.   Some  old utilities, however, may not be able to read zip
              traditionally encrypted entries, and this option may  be  useful
              in those cases.

              This  issue  only  involves Traditional zip encryption, which is
              considered rather weak nowadays.  AES  encryption  (such  as  -Y
              AES128)  does  not  have  this  problem.   In fact, the --etwodd
              option is only applicable to Traditional encryption and does not
              impact anything else.

       -E
       --longnames
              [OS/2]  Use the .LONGNAME Extended Attribute (if found) as file-
              name.

       -f
       --freshen
              Replace (freshen) an existing entry in the zip archive  only  if
              it  has  been modified more recently than the version already in
              the zip archive; unlike the update option (-u) this will not add
              files that are not already in the zip archive.  For example:

                     zip -f foo *.c

              replaces any files ending in .c that are newer than the versions
              in the archive.  This command should be run from the same direc-
              tory  from  which  the original zip command was run, since paths
              stored in zip archives are always relative.

              Note that the time zone environment variable TZ  should  be  set
              according  to  the  local time zone in order for options such as
              -f, -u and -o that compare times to work correctly.  The reasons
              behind  this are somewhat subtle but have to do with the differ-
              ences between the Unix-format file times  (always  in  GMT)  and
              most  of the other operating systems (always local time) and the
              necessity to compare the two.

              See the tzset man page for more information on setting TZ.   For
              example, for New Zealand TZ might be set to:

                     TZ="NZST-12.00:00NZDT-13:00:00,M10.1.0,M3.3.0"

              This  specifies  standard  time (NZST) is 12 hours ahead of UTC,
              and daylight saving time (NZDT), 13  hours  ahead of  UTC,  runs
              from  the  first Sunday in October to the third Sunday in March,
              and the changeovers happen at  the  default  time  of  02:00:00.
              Alternatively,  if  a  time  zone  file is available, TZ for New
              Zealand might be set to:

                     TZ=":Pacific/Auckland"

              Older systems may use the older format, TTThhDDD, where  TTT  is
              the  time zone such as MET, hh is the difference between GMT and
              local time such as -1 above, and DDD is the time zone when  day-
              light  savings time is in effect.  Leave off the DDD if there is
              no daylight savings time.  Using this  format,  the  US  Eastern
              time zone TZ would be set to EST5EDT.  Middle European time with
              automatic adjustment for "summertime" or Daylight  Savings  Time
              would be "MET-1MEST".

              Daylight  saving time can impact options that compare times when
              some entries are added during standard time and some during day-
              light saving time, or when the current daylight saving time sta-
              tus is different than when some or all of the entries were added
              or  updated in an archive.  In particular, options like -FS that
              look for time equality will likely not find time matches if  the
              archive is processed in a different time zone.

       -F
       --fix
       -FF
       --fixfix
              Fix the zip archive.  The -F option can be used if some portions
              of the archive are missing, but  requires  a  reasonably  intact
              central  directory.   The input archive is scanned as usual, but
              zip will ignore some problems.  The resulting archive should  be
              valid, but any inconsistent entries will be left out.

              When  doubled  as in -FF, the archive is scanned from the begin-
              ning and zip looks for special signatures to identify the limits
              between  the  archive members. The single -F is more reliable if
              the archive is not too much damaged, so try this option first.

              If the archive is too damaged or the end has been truncated, you
              must  use  -FF.   This  is  a change from zip 2.32, where the -F
              option is able to read a truncated archive.  The -F  option  now
              more  reliably  fixes  archives  with  minor  damage and the -FF
              option is needed to fix archives where -F might have been suffi-
              cient before.

              Neither  option will recover archives that have been incorrectly
              transferred in ascii mode instead of binary. After  the  repair,
              the  -t option of unzip may show that some files have a bad CRC.
              Such files cannot be recovered; you can  remove  them  from  the
              archive using the -d option of zip.

              Note  that  -FF may have trouble fixing archives that include an
              embedded zip archive that was stored  (without  compression)  in
              the  archive  and,  depending  on  the  damage,  it may find the
              entries in the embedded archive rather than the archive  itself.
              Try -F first as it better handles embedded archives.

              The  format  of  the fix commands have changed.  For example, to
              fix the damaged archive foo.zip,

                     zip -F foo --out foofix

              tries to read the entries normally, copying good entries to  the
              new  archive  foofix.zip.   If  this  doesn't  work, as when the
              archive is truncated, or if some entries you  know  are  in  the
              archive are missed, then try

                     zip -FF foo --out foofixfix

              and  compare the resulting archive to the archive created by -F.
              The -FF option may create an inconsistent archive.  Depending on
              what  is  damaged,  you  can  then use the -F option to fix that
              archive.

              A split archive with missing split files can be fixed  using  -F
              if  you  have the last split of the archive (the .zip file).  If
              this file is missing, you must use -FF to fix the archive, which
              will prompt you for the splits you have.

              Currently  the fix options can't recover entries that have a bad
              checksum or are otherwise damaged.

       -FI
       --fifo
              [Unix]  Normally zip  skips  reading  any  FIFOs  (named  pipes)
              encountered, as zip can hang if the FIFO is not being fed.  This
              option tells zip to read the contents of any FIFO it finds.

              zip 3.0 skipped FIFOs if -FI was not used.  zip 3.1 now  creates
              empty  entries  for  FIFOs if -FI is not used.  This shows where
              these FIFOs were, and will allow unzip to recreate the FIFOs  in
              the  future.   With  -FI,  zip 3.1 still stops and waits for the
              FIFO to be fed as with zip 3.0.

       -FS
       --filesync
              Synchronize the contents of an archive with the files on the OS.
              Normally  when  an  archive  is updated, new files are added and
              changed files are updated but files that no longer exist on  the
              OS  are not deleted from the archive.  This option enables a new
              mode that checks entries in the archive against the file system.
              If  the file time and file size of the entry matches that of the
              OS file, the entry is copied from the  old  archive  instead  of
              being  read  from  the file system and compressed (similar to -u
              for files that don't require updating).   If  the  OS  file  has
              changed,  the  entry  is  read  and compressed as usual.  If the
              entry in the archive does not match a file on the OS, the  entry
              is  deleted.   Enabling  this option should create archives that
              are the same as new archives, but  since  existing  entries  are
              copied  instead of compressed, updating an existing archive with
              -FS can be much faster than creating a new archive.   Also  con-
              sider using -u for updating an archive.

              For  this option to work, the archive should be updated from the
              same directory it was created in so the  relative  paths  match.
              If  few  files  are being copied from the old archive, it may be
              faster to create a new archive instead.

              Note that the time zone environment variable TZ  should  be  set
              according  to  the  local  time zone in order for this option to
              work correctly.  A  change  in  time  zone  since  the  original
              archive was created could result in no times matching and recom-
              pression of all files.  See -f for more on time zones.

              This option deletes files from the archive.  If you need to pre-
              serve  the original archive, make a copy of the archive first or
              use the --out option to output the  updated  archive  to  a  new
              file.  Even though it may be slower, creating a new archive with
              a new archive name is safer, avoids mismatches  between  archive
              and OS paths, and is preferred.

              zip  3.1  now  supports the use of -sf with -FS.  When these are
              used together, zip shows the differences between the archive and
              the  file system as a set of add, freshen and delete operations.
              This is a show files mode and the archive is not modified.

       -fd
       --force-descriptors
              Force use of data descriptors.  This is generally only used  for
              debugging.

       -fz
       --force-zip64
              Force  use  of  the Zip64 extensions.  This may be needed when a
              file is just under the 4 GiB limit but bad compression or use of
              -l  to  convert  to  Windows line ends pushes the resulting file
              over the limit.  Using -fz tells Zip to use the Zip64 large file
              extensions.  Negating this option (-fz-) will prevent the use of
              these extensions.

              zip 3.1 now handles files close to the 4 GiB limit  more  grace-
              fully  and  -fz  and  -fz-  should  not be needed except in rare
              cases.

       -g
       --grow
              Grow (append to) the specified zip archive, instead of  creating
              a  new  one.   This  can be fast if only a few entries are being
              added, as any old entries remain where they are in  the  archive
              as  new  entries  are  appended.   If  this operation fails, zip
              attempts to restore the archive to its original  state.  If  the
              restoration  fails,  the  archive  might  become corrupted. This
              option is ignored when there's no existing archive  or  when  at
              least one archive member must be updated or deleted.

              Before  using  this option, it may be a good idea to make a copy
              of the archive.

       -h
       -H
       -?
       --help
              Display the zip help information (this also appears  if  zip  is
              run with no arguments).

       -h2
       -hh
       -HH
       --more-help
              Display  extended  help  including  more on command line format,
              pattern matching, and more obscure options.

              Most major features of zip are covered in the extended help, and
              this  option  has evolved into a sort of mini man page and quick
              reference.

       -i files
       --include files
              Include only the specified files, as in:

                     zip -r foo .  -i \*.c

              which will include only files that end  in  .c  in  the  current
              directory  and its subdirectories in the archive foo.  (Note for
              PKZIP users: the equivalent command is

                     pkzip -rP foo *.c

              PKZIP does not allow recursion in  directories  other  than  the
              current one.)  The backslash avoids shell filename substitution,
              so that the name matching is performed by zip at  all  directory
              levels.  Double quotes can also be used:

                     zip -r foo .  -i "*.c"

              [This  is  for  Unix  and other systems where \ escapes the next
              character, in this case preventing the shell  from  replacing  *
              with  a  list of files in the current directory.  For other sys-
              tems where the shell does not expand * (does not do  file  glob-
              bing),  do  not  use  \ (as on MSDOS, for example, this would be
              handled as a directory separator, which  may  not  be  what  you
              want) and the above would be

                     zip -r foo .  -i *.c

              Examples are for Unix unless otherwise specified.]

              -i  accepts a list of file paths or patterns, where a pattern is
              a path that includes wildcards and paths are relative to the zip
              operation  root  (either  the current directory or the directory
              set by -cd if used).  When -i is used,  zip  proceeds  with  the
              file  system  scan as normal.  After the file list to operate on
              is generated, zip then filters that list using the  patterns  in
              the  -i  (include)  and -x (exclude) lists.  As -i and -x filter
              the files list, these are called filters.

              It's important to note that the size of the file  scan  (and  so
              how  long it takes) is not impacted by filters; they are applied
              after the scan.  If a scan  is  taking  a  long  time,  consider
              choosing  a  zip root directory farther down the tree or zipping
              specific subdirectories.  For instance, on Unix if  the  current
              directory is root (/):

                     zip foo -r .  -i "/usr/*"

              will have zip scan the entire system to come up with a file list
              that then will be cut down to just the /usr directory.

                     zip foo -r usr

              would likely be much faster.  (-pa can be used to prefix  "usr/"
              to the front of paths if needed.

                     zip foo -r usr -pa usr/

              for example.)

              Though the examples here focus on Unix paths (and Windows paths,
              as they are similar), other ports may use syntax similar to  how
              paths  are defined on that port.  For instance, on VMS -i and -x
              paths and patterns are specified similar to how  VMS  paths  are
              specified.

              -i  and  -x  take values in two forms.  If the option is immedi-
              ately followed by a pattern (no space, or "=" is used) the  list
              has  only  one item.  If there is white space between the option
              and the first pattern, this is a value  list  of  patterns  that
              terminates  either  at  the end of the line, the next option, or
              the special argument "@" (just @ with white  space  around  it).
              For example, in:

                     zip  -i=somefile.txt  archivename  -r  .

              -i  has  a list with one item, somefile.txt.  A one item list is
              self terminated.  (In practice, "=" must be  used  to  define  a
              single  file list, as characters immediately following "i" might
              be taken as part of the "i" option.  For example, "-icat"  would
              be  taken  as -ic, followed by -a and -t.  An exception is "-i@"
              described below.)  In contrast, in:

                     zip  archivename -r .  -i  somefile.txt  anotherfile

              -i has a two value list that terminates at the end of the  line,
              and  includes  somefile.txt  and anotherfile.  This can be rear-
              ranged as in:

                     zip  -i  somefile.txt  anotherfile  @  archivename  -r  .

              where @ is used to terminate the list.  Also equivalent is:

                     zip  -i  somefile.txt  anotherfile  -r  archivename  .

              where the -r option ends the list.

              On Unix, any wildcards in patterns need to be escaped to prevent
              the shell from expanding them, otherwise the  results  of  shell
              globbing  will be used by zip to filter the file list.  For com-
              plex patterns, it's typically easiest to enclose the entire pat-
              tern in double quotes:

                     zip  -RE  -i  "*.txt"  "*.[ch]"  -r  archivename  .

              where  -RE  is  needed  to  enable zip processing of the regular
              expression "[ch]".  This -i list will include files that end  in
              ".txt", ".c", and ".h".

              So to include dir, a directory directly under the current direc-
              tory, use

                     zip -r foo . -i "dir/*"

              to match paths such as dir/a and dir/b/file.c.  Note  that  cur-
              rently the trailing / is needed for directories (as in

                     zip -r foo . -i dir/

              to include directory dir and

                     zip -r foo . -i "dir/*"

              to include directory dir and its contents).

              But  note that the above just is demonstrating use of -i.  Actu-
              ally

                     zip -r foo dir

              would be more efficient to zip up dir and its contents.

              The long option form of the first example is

                     zip -r foo . --include \*.c

              and does the same thing as the short option form.

              Use -sc (show command line) to see how your command line will be
              parsed.   This  also  will  catch  if you left off a needed \ or
              quote and the shell expanded a wildcard.  -sc will  exit  before
              the file scan is actually done and so is relatively fast.

              Adding  -sf  (show files) to the command line will prompt zip to
              perform the file scan and filter the list, and then display  the
              list  of  files  to  operate  on  without  performing the actual
              archiving operation.

              Also possible:

                     zip -r foo  . -i@include.lst

              which will only include the files in the current  directory  and
              its   subdirectories   that  match  the  patterns  in  the  file
              include.lst, one file pattern per line.  (This is a variation of
              the  -i  option  and  should  not  be  confused with invoking an
              argfile.)  Note that zip 3.1 now removes  leading  and  trailing
              white  space  from  paths and patterns in the list read from the
              file.  (White space in the middle of a path or  pattern  is  not
              impacted.)   Put  double  quotes around any path or pattern that
              has leading or trailing white space.

              The above is the single item list format.  It's also possible to
              specify multiple include files and patterns:

                     zip -r foo  . -i @include.lst @include2.lst "*.txt"

              zip  will  perform  the  file scan, then filter the list to only
              include  files  that  match  a   pattern   in   include.lst   or
              include2.lst, or that end in ".txt".  The list terminates at the
              end of the line.  Note that @include.lst and  @include2.lst  are
              part  of the -i value list and so are read as include files, one
              path or pattern a line, not as argfiles.

              See -R for more on patterns and  -x  for  more  on  include  and
              exclude.  Also see the section on PATTERN MATCHING below.

              -i,  -x and -R are filters.  In the case of -i and -x, if recur-
              sion is enabled by -r, each directory tree listed on the command
              line  will  be traversed.  In the case of -R, the current direc-
              tory tree will be traversed.  Then the -i, -x  and  -R  patterns
              are  matched against the resulting list.  To save time, keep the
              directory trees searched as small as possible.  Instead  of  -R,
              consider a more targeted use of -r.

       -I
       --no-image
              [Acorn  RISC OS] Don't scan through Image files.  When used, zip
              will not consider Image  files  (eg.  DOS  partitions  or  Spark
              archives  when  SparkFS is loaded) as directories but will store
              them as single files.

              For example, if you have SparkFS loaded, zipping a Spark archive
              will  result  in  a zipfile containing a directory (and its con-
              tent) while using the 'I' option will result in a  zipfile  con-
              taining a Spark archive. Obviously this second case will also be
              obtained (without the 'I' option) if SparkFS isn't loaded.

       -ic
       --ignore-case
              [VMS, WIN32] Ignore case when matching  archive  entries.   This
              option  is  only available on systems where the case of files is
              ignored.  On systems with case-insensitive file systems, case is
              normally  ignored  when matching files on the file system but is
              not ignored for -f (freshen), -d (delete), -U (copy), and  simi-
              lar  modes  when  matching against archive entries (currently -f
              ignores case on VMS) because archive entries can be from systems
              where  case  does  matter and names that are the same except for
              case can exist in an archive.  The -ic option makes all matching
              case  insensitive.   This can result in multiple archive entries
              matching a command line pattern.

       -j
       --junk-paths
              Store just the name of a saved file (junk the path), and do  not
              store directory names.  By default, zip will store the full path
              (relative to the current directory).

              If negated, as in -j-, full relative paths are  stored  (cancels
              any previous -j on the command line).

       -jj
       --absolute-path
              [MacOS]  Record Fullpath (+ Volname).  The complete path includ-
              ing volume will be stored.  By default the relative path will be
              stored.

       -J
       --junk-sfx
              Strip  any prepended data (e.g. a self extracting SFX stub) from
              the archive.

       -k
       --DOS-names
              Attempt to convert the names and  paths  to  conform  to  MSDOS,
              store  only  the  MSDOS attribute (just the user write attribute
              from Unix), and mark the entry as made under MSDOS (even  if  it
              was  not); for compatibility with PKUNZIP under MSDOS which can-
              not handle certain names such as those with two dots.

       -kf keyfilepath
       --keyfile keyfilepath
              When encrypting, a key is needed.  The key is normally the pass-
              word,  either prompted for (by using -e or -Y) or provided using
              -P.  zip 3.1 now supports providing part or all of the key using
              the  contents  of  a  file.   The file providing the contents is
              called a keyfile.

              When -kf is used, the file at keyfilepath is used  as  the  key-
              file.

              When using AES encryption, the password to zip is limited to 128
              bytes.  This is a limitation of the AES  encryption  implementa-
              tion.   (Traditional encryption has a longer maximum length, but
              due to the weak nature of Traditional encryption the same  algo-
              rithm  described  below  is  used  for  both Traditional and AES
              encryption.)

              When -kf is used to specify a keyfile, the file is opened and up
              to  the  first  128  non-NULL  bytes  are read from it.  This is
              buffered as possible key content in a keyfile buffer.  Note that
              this content can include any byte values except for NULLs, which
              are skipped.

              When -kf is used and -e or -P are not used, the entire  contents
              of the keyfile buffer is used as the password.

              When  -kf is used and a password is also specified, the password
              is used as the first part of the key.  Then any remaining  space
              up  to the 128 byte limit is filled in using the contents of the
              keyfile buffer.  So essentially the keyfile buffer contents  are
              appended to the password to form the key, and then the key trun-
              cated to 128 bytes.

              If the keyfile buffer contains normal text, the result is equiv-
              alent  to  specifying the entire key as the password.  This fact
              can be used to pass the keyfile content to a utility  that  does
              not  recognize keyfiles by just appending the keyfile content to
              the  specified  password.   However,  if  the  keyfile   content
              includes  binary,  this  may  not work and a utility that under-
              stands the implementation of keyfiles used by zip may need to be
              used.

       -l
       --to-crlf
              Translate  the Unix end-of-line character LF (linefeed, \n) into
              the MSDOS convention CR LF (carriage return and linefeed, \r\n).
              This  option  should not be used on binary files, and zip checks
              files for binary before performing the conversions.

              This option can be used on Unix if the zip file is intended  for
              MSDOS  or Windows, converting Unix format text to Windows format
              text. If the input files already contain CR LF, this option adds
              an  extra  CR.  This is to ensure that unzip -a on Unix will get
              back an exact copy of the original file, to undo the  effect  of
              zip -l.

              See -ll for more on how binary files are handled.

       -la
       --log-append
              Append to existing logfile.  Default is to overwrite.

       -lf logfilepath
       --logfile-path logfilepath
              Open  a logfile at the given path.  By default any existing file
              at that location is overwritten, but the -la option will  result
              in  an  existing  file  being opened and the new log information
              appended to any existing information.  Only warnings and  errors
              are written to the log unless the -li option is also given, then
              all information messages are also written to the log.

       -lF
       --log-output
              Open a logfile as -lf, but use  the  same  path  as  the  output
              archive  except  that  the  .zip  extension is replaced by .log.
              This option is useful if the archive path is not known (as in  a
              script) or to avoid typing a long path twice.

       -li
       --log-info
              Include  information  messages, such as file names being zipped,
              in the log.  The default is to only include  the  command  line,
              any warnings and errors, and the final status.

       -ll
       --from-crlf
              Translate  MSDOS/Windows  CR  LF  (carriage return and linefeed,
              \r\n) line ends into Unix LF (linefeed,  \n)  line  ends.   This
              option  should  not  be used on binary files, and zip will check
              for binary before converting the line ends.

              This option can be used on MSDOS or Windows if the zip  file  is
              intended  for  unzip under Unix, converting Windows line ends to
              Unix line ends.

              As -ll removes the CR from CR LF line end pairs, it is  possible
              that the results can't be reversed by -l, especially if the file
              had a mix of Windows and Unix line ends.

              The first couple buffers  of  each  file  to  be  converted  are
              checked for binary.  (How many characters are checked varies for
              each compression method, but generally this is  a  few  thousand
              characters, or the whole file if smaller than that.)  This check
              is used to determine if the file is text (has no  binary).   zip
              then  proceeds  with  the  conversions  if the file is text.  If
              later the file is found to  contain  binary,  a  corrupted  file
              warning is issued.

              As of zip 3.1, if binary is found during the conversion, and the
              output file is seekable and rewritable, zip  will  back  up  and
              reprocess the file as binary.  This corrects the original incor-
              rect text/binary decision.  No conversions are  done  on  binary
              files  (except  for EBCDIC to ASCII conversions when -aa is used
              to force them).  If the output is not rewritable, zip  issues  a
              corruption warning and leaves the file as is.  Generally we find
              the first couple buffers check to be very reliable, only failing
              on test files we create to fool it, but the user should be aware
              that it can fail.

              Usually, for speed, zip uses the  result  of  the  first  couple
              buffers  check  to  set  the  text/binary attribute of the file.
              However, the -BF (binary full check) option can be used to force
              checking  the  entire  file  for binary.  When -l, -ll or -a are
              used, -BF is automatically set so the entire file is checked  to
              validate the conversion was done to a text file.

              As  of  zip 3.0, a new algorithm is being used for binary detec-
              tion.  UTF-8, for instance, now is considered text and  will  be
              processed as such.

       -lu
       --log-utf8
              Put  file  paths  in log as UTF-8.  Need an application that can
              understand UTF-8 to  accurately  read  the  log  file,  such  as
              Notepad on Windows XP and later.

              zip  should  now  be sending UTF-8 to the console if the console
              can handle it.  If it isn't already getting UTF-8,  sending  log
              output to stdout to see UTF-8 probably won't work.  If your con-
              sole can understand UTF-8 and UTF-8 is not already being sent to
              the  console,  the -UN=ShowUTF8 option can be used to pass UTF-8
              to the console.

              Note that on Windows, zip 3.1 now sets -UN=ShowUTF8  by  default
              and writes Unicode directly to the console.  However, because of
              deficiencies with the Windows command window, full  UTF-8  can't
              be  displayed.   For  instance,  if  English is the OS language,
              Asian fonts (such as  Japanese)  may  not  display  (just  boxes
              instead).   This is a deficiency in the console window, not zip.
              However, copying and pasting those boxes to a Unicode aware edi-
              tor  (such as Notepad) will show that these are the correct Uni-
              code characters.

       -L
       --license
              Display the zip license.

       -m
       --move
              Move the specified files into the zip  archive;  actually,  this
              deletes  the target directories/files after making the specified
              zip archive.  If a directory  becomes  empty  after  removal  of
              files,  the  directory  is  also removed.  No deletions are done
              until zip has created the archive without error.  This is useful
              for conserving disk space, but is potentially dangerous so it is
              recommended to use it in combination with -T to test the archive
              before removing all input files.

       -MM
       --must-match
              All  input  patterns  must match at least one file and all input
              files found must be readable.

              Normally when an input pattern does not match a file  the  "name
              not  matched" warning is issued, and when an input file has been
              found but later is missing or not readable a  "could  not  open"
              warning  is  issued.   In either case zip continues creating the
              archive, with missing or unreadable new files being skipped  and
              files  already  in  the  archive remaining unchanged.  After the
              archive is created, if any files were not readable  zip  returns
              the  OPEN  error code (18 on most systems) instead of the normal
              success return (0 on most systems).

              With -MM set, zip exits as soon  as  an  input  pattern  is  not
              matched  (whenever  the  "name  not  matched"  warning  would be
              issued) or when an input file is not readable.  In  either  case
              zip exits with an OPEN error and no archive is created.

              This option is useful when a known list of files is to be zipped
              so any missing or unreadable files will result in an error.   It
              is less useful when used with wildcards, but zip will still exit
              with an error if any input pattern doesn't match  at  least  one
              file  and  if  any matched files are unreadable.  If you want to
              create the archive anyway and only need to know  if  files  were
              skipped,  don't  use -MM and just check the return code.  If you
              need to know what names were not matched and which  files  could
              not  be  opened,  consider  logging  the operation using -lf and
              checking the log afterwards.

       -MV mode
       --MVS-mode mode
              [MVS] Set the MVS path translation mode to mode.  Paths  on  MVS
              are  generally  in the form aa.bb.cc.dd, where the dots separate
              the parts of the path.  To make these paths more compatible with
              non-MVS  systems, zip converts the dots to slashes.  The default
              translation has caused problems, however,  so  this  option  now
              allows control of how the paths are translated.  mode can be:

              dots  - Store paths as they are on the file system (typically in
              the form aa.bb.cc.dd).

              slashes - Change MVS paths in form aa.bb.cc.dd (using  dots)  to
              aa/bb/cc/dd (using slashes).

              lastdot  - Change paths in form aa.bb.cc.dd to aa/bb/cc.dd where
              all but the last dot is  converted  to  slashes.   This  is  the
              default for backward compatibility and is probably the most com-
              patible format for old MSDOS 8.3 file systems.

              mode can be appreviated to the first letter (d, s, or l).

       -n suffixes
       --suffixes suffixes
              Do not attempt to compress files ending with the given  suffixes
              (file  extensions,  on Unix, Windows, VMS, and similar systems).
              Such files are simply stored (no compression) in the output  zip
              file,  so  that  zip doesn't waste time trying to compress them.
              The suffixes are separated by either colons or semicolons.   For
              example:

                     zip -rn .Z:.zip:.tiff:.gif:.snd  foo foodir

              will  compress  everything  from  foodir  into foo.zip, but will
              store any files that end in .Z, .zip, .tiff, .gif, or .snd with-
              out  trying  to  compress them (image and sound files often have
              their own specialized compression  methods).   By  default,  zip
              does not compress files with the following extensions:

              .7z  .arc .arj .bz2 .cab .gz .lha .lzh .lzma .pea .rar .rz .tbz2
              .tgz .tlz .txz .xz .Z .zip .zipx .zoo .zz

              (This list subject to change.)  Such files are  stored  directly
              in  the  output archive.  The environment variable ZIPOPT can be
              used to change the default options on a  more  permanant  basis.
              For example under Unix with csh:

                     setenv ZIPOPT "-n .gif:.zip"

              To attempt compression on all files, use:

                     zip -n : foo

              where the single : is an empty -n list.  The maximum compression
              option -9 previously attempted compression on all files  regard-
              less  of extension, but now zip 3.1 lets -9 also obey the suffix
              list.  To get the previous -9 behavior, use -9 and -n ::

                     zip -9n : foo file1 file2

              On Acorn RISC OS systems the suffixes are actually filetypes  (3
              hex digit format).  By default, zip does not compress files with
              filetypes in the list DDC:D96:68E (i.e. Archives, CFS files  and
              PackDir files).

              As  of zip 3.1, the -n option now allows additional control over
              which compression method is used for each suffix.   The  general
              enhanced forms of this option are:

                     -n Method=SuffixList

              and

                     -n Method-Level=SuffixList

              The  first  form  allows setting a list of suffixes that use the
              specified Method, overriding any global compression  method  set
              by  -Z when files with a suffix in SuffixList are processed.  So
              when a file with one of the listed  suffixes  is  processed,  it
              will be compressed using Method.

              The  second  form  allows even finer granularity, forcing use of
              Method at compression level Level to compress files  whose  suf-
              fixes  are in SuffixList, overriding any general -Z and -0 to -9
              compression and level settings.  (Setting a level of  0  is  not
              allowed  as it would force use of Store instead of the specified
              compression method.)

              Method is any valid method that would be provided to -Z.   Level
              is a single digit from 1 to 9 representing the compression level
              that would be specified by the options -1 .. -9, or can  be  "-"
              to specify the default compression level.

              The  Store  compression  method  (-0,  no compression) cannot be
              overridden, the method for Store always being Store.

              SuffixList is specified as a colon-separated list.  A list  with
              just  ":" is the empty list.  (";" can be used instead of ":" as
              the list separator.)

              When a list is supplied for a compression method (Store,  if  no
              method is given), it wipes out any previous list.  For instance

                     -n .zip:.txt

              would  wipe out the default Store list.  To include any previous
              list contents, use "*", as in

                     -n "*:.zip:.txt"

              The * must be escaped or quoted on Unix.  The * is  replaced  by
              the  current  list.   Using  *,  it's  possible  to  chain lists
              together, as in

                     -n "*:.zip:.txt"  -n "*:.gz"

              This works for other compression methods as well:

                     -n "lzma=.zip"  -n "lzma=*:.gz"

              If a suffix is listed in more than one -n, the last one  on  the
              command  line  including  the  suffix controls that suffix.  For
              instance

                     -n "lzma=.zip"  -n "ppmd=*:.zip"

              Given .zip starts in the default Store list, the first -n  pulls
              .zip  from  the Store list and puts it in the LZMA list, and the
              second -n pulls it from the LZMA list and puts it  in  the  PPMd
              list.  A suffix can only be in one list.

              For  example,  to use LZMA compression with .txt and .log files,
              but otherwise use default Deflate compression on all other files
              not in the default Store list, use:

                     zip archive *  -n lzma=.txt:.log

              To  use  PPMd  compression  at compression level 8 with .txt and
              .log files:

                     zip archive *  -n ppmd-8=.txt:.log

              As a more complex example:

                     zip archive *  -Z bzip2  -8  -n lzma-6=.exe:.obj:.olb

              Files matching suffixes in ".exe:.obj:.olb" will  be  compressed
              with  LZMA  at  level 6.  Files matching suffixes in the default
              Store suffix list are stored.  Other files  will  be  compressed
              using bzip2 at level 8.

              See  also  -1  .. -9 for setting a default compression level for
              specific compression methods.

       -nw
       --no-wild
              Do not perform internal wildcard processing (shell processing of
              wildcards  is  still  done by the shell unless the arguments are
              escaped).  Useful if a list of paths is being read and no  wild-
              card substitution is desired.

       -N
       --notes
              [Amiga,  MacOS]  Save  Amiga  or MacOS filenotes as zipfile com-
              ments. They can be restored by using the -N option of unzip.  If
              -c  is  used  also, you are prompted for comments only for those
              files that do not have filenotes.

       -o
       --latest-time
              Set the "last modified" time of the zip archive  to  the  latest
              (oldest) "last modified" time found among the entries in the zip
              archive.  This can be used  without  any  other  operations,  if
              desired.  For example:

              zip -o foo

              will change the last modified time of foo.zip to the latest time
              of the entries in foo.zip.

              -o can be impacted if entries in the archive  were  added  under
              different time zones.  See -f for more on time zones.

       -O output-file
       --output-file output-file
              Process  the  archive  changes as usual, but instead of updating
              the existing archive, output a new archive to output-file.  Use-
              ful  for  updating  an  archive  without  changing  the existing
              archive and the input archive must be a different file than  the
              output archive.

              This  option  can  be used to create updated split archives.  It
              can also be used with  -U  to  copy  entries  from  an  existing
              archive to a new archive.  See the EXAMPLES section below.

              Another  use  is  converting  zip  files  from one split size to
              another.  For instance, to convert an archive with 700  MB  (CD)
              splits to one with 2 GB (DVD) splits, can use:

                     zip -s 2g cd-split.zip --out dvd-split.zip

              which  uses  copy  mode.   (If  --out  is used without any input
              files, copy mode is assumed.  See -U below.)  Also:

                     zip -s 0 split.zip --out unsplit.zip

              (split size of zero) will convert a split archive to  a  single-
              file archive.  (-s- will also set the split size to zero.)

              Copy  mode  will  convert stream entries (using data descriptors
              and which should be  compatible  with  most  unzips)  to  normal
              entries  (which should be compatible with all unzips), except if
              Traditional encryption was used.  For  archives  with  encrypted
              entries, zipcloak can be used to decrypt the entries and convert
              them to normal entries.  But lately it seems most utilities  out
              there  will  read entries using data descriptors so this may not
              be as big an issue as it once was.

       -p
       --paths
              Include relative file paths as part of the names of files stored
              in  the  archive.  This is the default.  The -j option junks the
              paths and just stores the names of the files.

              Note that -p and -j- are equivalent.

       -pa prefx
       --prefix-add-path prefx
              Prefix paths of added/updated files with the string prefx.   The
              string  must  include  only alphanumeric and limited punctuation
              characters.  No spaces are allowed.  Slashes are allowed so that
              the prefix can put the new/updated files into a directory.

              Note  that prefixing is done to archive paths in the Unix format
              (with slash directory separators), not to the OS  format  paths.
              So, given the current directory is foo:

                     zip  archive  *  -pa foo/

              should  put all the files in the foo directory into a foo direc-
              tory in the archive on most all systems.

              Currently  only  alphanumeric  characters  and  the   characters
              "!@#$%^&()-_=+/[]{}|" are allowed in prefixes.  This list may be
              restricted further on some OS.

              See  also  -pp  (--prefix-path),  -Cl  (--case-lower)  and   -SI
              (--name-stdin).

       -pn
       --non-ansi-password
              Normally  a password is forced to only use ANSI 7-bit characters
              to avoid character set  issues  when  an  archive  is  moved  to
              another  system  or  locale.  This option allows the password to
              include any characters, such as UTF-8.

       -pp prefx
       --prefix-path prefx
              Prefix all paths in the archive  with  the  string  prefx.   The
              string  must  include  only alphanumeric and limited punctuation
              characters.  No spaces are allowed.  Slashes are allowed so that
              the prefix can put the archive contents into a directory.

              See also -pa and -Cl.

       -ps
       --allow-short-pass
              AES  encryption  (not Traditional encryption) requires a minimum
              password length dependent on the level of  encryption  selected.
              This  is to avoid encrypting a file using a strong algorithm but
              using such an easy to crack  password  that  the  encryption  is
              essentially  useless.  The minimums are still weak (see -Y), but
              are hopefully short enough to be  used.   Ideally  the  password
              length should approach the key length for the encryption used.

              This  option disables the password length checks.  A zero length
              password is still not allowed, however.  -ps is mainly  provided
              for testing and should not be used if security is a concern.

       -pt
       --performance-time
              The -pt option enables timing of the execution of zip.  When -pt
              is included in the command line,  zip  will  note  the  time  it
              starts  up.  When the operation finishes, a message is displayed
              noting how long the operation took.  The time is  provided  with
              millisecond accuracy.

              This  option  is  only  available  on  systems where an accurate
              enough clock is available to provide millisecond timing.

              This option is intended as a way to get  execution  timing  data
              regardless of the system and how zip is invoked.

       -pu
       --pswd-to-unzip
              As  of  zip  3.1, when -T is used to test the archive after cre-
              ation, any password given to zip (via -e or  -Y  (prompted),  or
              directly  by  -P)  is no longer passed on to unzip unless -pu is
              used.  This change generally results in unzip prompting for  the
              password.   As  the  password is no longer passed on the command
              line (using -P) by default, this is inherently safer.  Including
              -pu  on the command line will restore passing the password given
              to zip to unzip.

              See -T for more on testing archives.

       -P password
       --password password
              Use password to encrypt zipfile entries (if any).  THIS IS INSE-
              CURE!   Many  multi-user  operating systems provide ways for any
              user to see the current command line of any other user; even  on
              stand-alone  systems  there  is  always  the threat of over-the-
              shoulder peeking.  Storing the plaintext password as part  of  a
              command  line  in  an  automated script is even worse.  Whenever
              possible, use the non-echoing, interactive prompt (-e or -Y)  to
              enter passwords.

              (And  where  security  is  truly  important,  be sure to use AES
              encryption with a strong password,  or  an  external  encryption
              program  such  as  GNU Privacy Guard (GnuPG, gpg) instead of the
              relatively weak Traditional zip encryption.)

              (As of zip 3.1 it's now possible to use -P in an  argument  file
              and then use the argument file on the command line.  This effec-
              tively hides the password, but then security of the argfile must
              be  maintained to prevent another user from opening the file and
              seeing the password.  However, this approach is still limited to
              text  passwords.   See  -kf for a way to get around this limita-
              tion.)

              See -Y for more on encryption.

              See -pu and -T for more on how passwords  are  passed  to  unzip
              when using -T to test the resulting archive.

       -q
       --quiet
              Quiet   mode;   eliminate  informational  messages  and  comment
              prompts.  (Useful, for example, in shell scripts and  background
              tasks).

       -Qn
       --Q-flag n
              [QDOS]  Store information about the file in the file header with
              n defined as
              bit  0: Don't add headers for any file
              bit  1: Add headers for all files
              bit  2: Don't wait for interactive key press on exit
       For backward compatibility this is a number value following  the  short
       option without a space.

       -r
       --recurse-paths
              Travel the directory structure recursively; for example:

                     zip -r foo.zip foo

              or more concisely

                     zip -r foo foo

              In this case, all the files and directories in directory foo are
              saved in a zip archive named foo.zip, including files with names
              starting  with  "."  (on Unix), since the recursion does not use
              the shell's file-name substitution mechanism.  If  you  wish  to
              include only a specific subset of the files in directory foo and
              its subdirectories, use the -i option to specify the pattern  of
              files to be included.  You should not use -r with the name ".*",
              since that matches ".."  which will attempt to zip up the parent
              directory (probably not what was intended).

              Multiple source directories are allowed as in

                     zip -r foo foo1 foo2

              which  first  zips up foo1 and then foo2, going down each direc-
              tory.

              Note that while wildcards to -r  are  typically  resolved  while
              recursing  down  directories in the file system, any -R, -x, and
              -i wildcards are applied to internal archive pathnames once  the
              directories are scanned.

              To  have wildcards apply to files in subdirectories when recurs-
              ing on Unix and similar systems where the  shell  does  wildcard
              substitution,  either  escape all wildcards or put all arguments
              with wildcards in quotes.  This lets zip see the  wildcards  and
              match files in subdirectories using them as it recurses.

              Previously  zip did not process wildcards in input file names on
              Unix, so any escaped wildcards on the command line used as  part
              of an input file were kept as literal characters.  (Wildcards in
              patterns to -i, -x, and -R have always  been  processed  by  zip
              when  escaped,  and  should  always be escaped.)  As of zip 3.1,
              escaped wildcards in input file names are now processed by  zip.
              Unescaped wildcards will still be processed by the shell.

       -R
       --recurse-patterns
              Travel the directory structure recursively, starting at the cur-
              rent directory, and match the ends of paths  against  the  given
              patterns.  For example:

                     zip -R foo "*.c"

              In  this  case,  all relative file paths starting at the current
              directory where the end of the path matches *.c are stored  into
              a  zip  archive  named  foo.zip.   More  than one pattern can be
              listed as separate arguments.  Note for PKZIP users: the equiva-
              lent command is

                     pkzip -rP foo *.c

              Patterns  are relative file paths as they appear in the archive,
              or will after zipping, and can have optional wildcards in  them.
              On Unix and other systems where the shell expands wildcards, all
              patterns should be quoted, or the wildcards escaped, to keep the
              shell from replacing them with file lists.

              As  an  example, given the current directory is foo and under it
              are directories foo1 and foo2 and in foo1 is the file bar.c  and
              in foo2 is bar.c and also directory foo22 and in that bar2.c:

                     foo/foo1/bar.c

                     foo/foo2/bar.c

                     foo/foo2/foo22/bar2.c

              Then

                     zip foo -R "bar.c"

              will include foo1/bar.c and foo2/bar.c in the archive foo.zip.

              For each pattern given on the command line, -R counts the number
              of directory components in the pattern.  Let's call that n.  The
              number  of components in a pattern (n) is one more than the num-
              ber of slashes in the pattern.  (The slash (/) is always used as
              the  directory  separator for paths in an archive, which is what
              -R patterns are matching against.)

              Then -R compares the last n components  of  each  path  to  that
              pattern and, if they match, the path is included.  So above, the
              pattern bar.c has no slashes and so n = 1 and  only  paths  that
              end  in the name "bar.c" are included in the archive.  Note that
              directories always end in "/" and so will not be matched  unless
              the pattern ends in "/".

              As another example,

                     zip foo -R "foo*/*"

              has two components ("foo*" and "*"), so n = 2.  So only the last
              two components of paths will be matched  against  this  pattern.
              Note  that  when  -R is used, "*" only matches one component and
              does not span directory boundaries.  So  only  paths  where  the
              next  to  last  component  matches "foo*" and the last component
              matches "*" will be included in the archive foo.  So foo1/bar.c,
              foo2/bar.c, and foo2/foo22/bar2.c will be included.  In the last
              case, "foo22/bar2.c" is compared to "foo*/*", and  matches,  and
              so is included.

              On  Unix,  all input patterns should be quoted, or any wildcards
              escaped, as the wildcards are part of the  patterns  zip  is  to
              match  against  as  it recurses.  Letting the shell process them
              will likely have undesired results.  See -r for more on escaping
              wildcards.

              -i and -x can be used to filter the matches further.

              See -i and -x for more on pattern matching.

       -RE
       --regex
              Before  zip 3.0, list matching was enabled by default on Windows
              platforms.  Because of confusion  resulting  from  the  need  to
              escape  "["  and  "]"  in  names, as of zip 3.0 it is now off by
              default for Window so "[" and "]" are just normal characters  in
              names.   This  option  enables  bracketed  list  matching again.
              Since then we've had complaints on other platforms,  so  in  zip
              3.1  use  of  []  for list matching is now off for all platforms
              unless -RE is used.

              Note that for shells that recognize []  lists  (such  as  modern
              Unix shells), it's still necessary to escape [ and ] (unless you
              want the shell to process the [] lists).

              -RE enables the use of "[" and "]"  for  delimiting  a  list  of
              characters where if any character in that list matches the char-
              acter at the position the square bracketed list is that  charac-
              ter  is  matched.  Essentially a bracketed list acts as a selec-
              tive wildcard.  For instance,

                     zip zipfile "foo[abc]"

              would look for a file named foo[abc], while

                     zip zipfile "foo[abc]" -RE

              would match files  fooa,  foob,  and  fooc.   On  Unix,  without
              quotes, as in

                     zip zipfile foo[abc]

              the shell would process the list, and fooa, foob, and fooc would
              be matched.

              Examples of list patterns when -RE enabled:

              [abcd] - Match any one of characters a, b, c, d.

              [a-d] - Match any character in range (a, b, c, d).

              [!a-d] - Match any character not in the range.  (Leading ! or  ^
              negates range.)

              [[] - Match "[".

              [ad-f[3] - Match a, d, e, f, [, or 3.

              -nw turns off wildcard matching, including bracketed list match-
              ing (if escaped).

              See the section on PATTERN MATCHING below for more on  wildcards
              and matching.

       -s splitsize
       --split-size splitsize
              Enable creating a split archive and set the split size.  A split
              archive is an archive that could be split over many  files.   As
              the  archive  is created, if the size of the archive reaches the
              specified split size, that split is closed and  the  next  split
              opened.   In  general  all splits but the last will be the split
              size and the last will be  whatever  is  left.   If  the  entire
              archive is smaller than the split size, a single-file archive is
              created.

              Split archives are stored in numbered files.   For  example,  if
              the  output  archive  is  named  archive  and  three  splits are
              required, the resulting archive  will  be  in  the  three  files
              archive.z01,  archive.z02,  and  archive.zip.  Do not change the
              numbering of these files or the archive will not be readable  as
              these are used to determine the order splits are read.

              Split  size  is  a  number  optionally followed by a multiplier.
              Currently the number must be an  integer.   The  multiplier  can
              currently be one of k (kilobytes), m (megabytes), g (gigabytes),
              t (terabytes), or p (petabytes).  (Note that these are powers of
              2,  so  k  = 1024 and so on.)  As 64k is the minimum split size,
              numbers without multipliers default to megabytes.  For  example,
              to  create  a  split archive called foo with the contents of the
              bar directory with splits of 670 MB that  might  be  useful  for
              burning on CDs, the command:

                     zip -s 670m -r foo bar

              could be used.

              Currently  the  old  splits  of a split archive are not excluded
              from a new archive with the same name (and so would be  included
              in  the  new  archive if in scope), but they can be specifically
              excluded.  If possible, keep the input and output  archives  out
              of the path being zipped when creating split archives.

              Using  -s  without -sp as above creates all the splits where foo
              is being written, in this  case  the  current  directory.   This
              split  mode  updates the splits as the archive is being created,
              requiring all splits  to  remain  writable,  but  creates  split
              archives  that  are readable by any unzip that supports standard
              split archives.  See -sp below for  enabling  split  pause  mode
              which allows splits to be written directly to removable media.

              The  option  -sv  can be used to enable verbose splitting, which
              provides details of how the splitting is being done.

              Split archives cannot be updated, but see -O (big o, --out)  for
              how  a  split  archive  can  be updated as it is copied to a new
              archive.  A split archive can also be converted into  a  single-
              file  archive  using a split size of 0 (zero) or negating the -s
              option:

                     zip -s 0 split.zip --out single.zip

              unzip 6.00 does not support split  archives.   Some  workarounds
              include  using zip to convert the split archive to a single file
              archive that unzip can read.  Another is to combine  the  splits
              manually  into  one  file,  which  unzip  can  process with some
              effort, adjusting the now incorrect offsets in the archive.  Yet
              another  possibility  is  using  zipsplit  to  convert the split
              archive into a set of normal archives, which unzip can  read  by
              using a wildcard in the zip file name given to unzip.

              The current unzip 6.1 beta now does support split archives.

              See  -U  (--copy)  and -O (--output-file) for more on using copy
              mode.

       -sb
       --split-bell
              If splitting and using split pause mode, ring the bell when  zip
              pauses for each split destination.

       -sc
       -sc=mode
       --show-command
       --show-command=mode
              Show  the  command line to zip (as zip parsed it) and exit.  The
              new command parser permutes the arguments, putting  all  options
              and  any values associated with them before any non-option argu-
              ments.  This allows an option to appear anywhere in the  command
              line  as  long as any values that go with the option immediately
              follow it.  This option displays the command line  as  zip  sees
              it,  including  any arguments from the environment, such as from
              the ZIPOPT variable, as well as the results  of  processing  any
              argfiles.  Once the command line is displayed, zip exits without
              performing the file scan or any processing.

              The -sc option is useful when a zip command line is not  execut-
              ing  as  expected.   It allows seeing just what the command line
              is, including any shell wildcard expansions that may or may  not
              be intended.

              -sc  normally  displays  the  command  line as read, showing the
              arguments in the final  order  they  will  be  processed.   This
              includes  any  environment  and argfile content.  This is "read"
              mode and is generally sufficient to see what's going on  and  is
              the  default  mode.  If mode is set to "parsed", zip goes a step
              further and rebuilds the command  line  based  on  how  internal
              structures  were set.  This can sometimes help identify a bug in
              zip, but usually "read"  mode  is  best  for  debugging  command
              lines.   Note  that  "read"  mode  presents  a command line that
              should be a valid command line that zip can  read  and  process.
              The output of "parsed" mode currently may not be a valid command
              line.  If mode is set to "all", the  "read"  mode  and  "parsed"
              mode outputs are both displayed.

              See  -sf  (--show-files)  as  a  way to see what files zip would
              operate on.

       -sd
       --show-debug
              Output debugging messages detailing what zip is doing each  step
              of  the  way.  We use this as a development tool, but found this
              feature can be useful to help users track down bugs and so  left
              it in the release version of zip.

       -sf
       --show-files
              Show  the  files  that  would  be  operated  on, then exit.  For
              instance, if creating a new archive, this will  list  the  files
              that  would  be  added.   If the option is negated, -sf-, output
              only to an open log file.  Screen display is not recommended for
              large lists.

              If  the  command line contains no input files, -sf will show the
              contents of an archive (similar to unzip -l).

              See -sF to add information to the files listing provided by -sf.

              When  used  with  -FS,  -sf  shows  the  differences between the
              archive and the file system.  See -FS for more on this.

              -i and -x can be used with -sf to filter the list.  This  allows
              listing all *.txt files in an archive, for instance.

              See also -su and -sU.

       -sF param
       --sf-params param
              Add additional information to the -sf listing.

              Currently the following are supported:

                     usize     adds uncompressed size in parentheses after the
                     name

                     comment   adds file comment under the name

              Example:

                     zip -sf -sF usize archive

              This would list all files in  archive  and  include  the  uncom-
              pressed size of each file in the listing.

              Currently  to  include  both  usize and comment, they need to be
              specified in separate -sF options.

       -si
       --show-pid
              [UNIX, when enabled] Display the PID of the zip  process.   This
              is  useful  if the progress reporting feature is enabled and the
              PID is needed to signal the zip process.

       -so
       --show-options
              Show all available options supported by zip as compiled on  this
              system.   As  this  command  reads  the  option table, it should
              include all available options.  Each  line  includes  the  short
              option (if defined), the long option (if defined), the format of
              any value that goes with  the  option,  if  the  option  can  be
              negated,  and  a small description.  The value format can be "no
              value", "required value", "optional  value",  "single  character
              value",  "number  value",  or a "list of values".  The output of
              this option is not intended to show how to use  any  option  but
              only show what options are available.

              Note  that  "single  character  value" and "number value" option
              values require the option value to be next to the option,  with-
              out spaces.  This is to maintain backward compatibility with how
              these option values were defined in zip 2.x.

       -sp
       --split-pause
              If splitting is enabled with -s, enable split pause mode.   This
              creates split archives as -s does, but stream writing is used so
              each split can be closed as soon as it is written and  zip  will
              pause  between each split to allow changing split destination or
              media.

              The -sb option can be used to ring the bell when zip pauses  for
              the next split destination.

              Though  this split mode allows writing splits directly to remov-
              able media, it uses the stream archive format that  may  not  be
              readable  by some unzips.  Before relying on splits created with
              -sp, test a split archive with the unzip you will be using.

              To convert a stream split archive (created with -sp) to a  stan-
              dard archive see the -O (--output-file) option.

              If  space  is available, it may be easier to just use -s without
              -sp and then burn the splits to removable media.

       -ss
       --show-suffixes
              Show the current settings  for  file  suffixes.   This  list  is
              impacted by -n and the -0 through -9 options.

       -st
       --stream
              This  option  enables  stream mode, where central directory file
              information is also stored local to each stored  file.   Archive
              entries  created using stream mode are fully extractable using a
              stream reading unzip, where as normal entries  need  information
              from  the  central  directory  (at the end of the archive) to be
              fully extracted.

       -su
       --show-unicode
              Similar to -sf, but also shows Unicode versions of the paths  if
              they exist.

       -sU
       --show-just-unicode
              Similar  to  -sf,  but shows only Unicode versions of the paths.
              If a Unicode version doesn't exist, show the standard version of
              the path.

       -sv
       --split-verbose
              Enable various verbose messages while splitting, showing how the
              splitting is being done.

       -S
       --system-hidden
              [MSDOS, OS/2, WIN32 and ATARI] Include system and hidden  files.
              [MacOS]  Includes finder invisible files, which are ignored oth-
              erwise.

       -SI newname
       --rename-stdin newname
              Rename stdin.  Normally when zip receives input from stdin,  the
              resulting  archive  entry  is  named  "-".   -SI  renames "-" to
              another name in the archive.

              This can be useful when the receiver of the  archive  prefers  a
              more  descriptive  name for the content.  -SI can also be useful
              when multiple entries are being added to an archive (at  differ-
              ent times) from stdin.  This option allows each content received
              from stdin to have a unique name.

              newname follows the same rules as used by -pa and -pp to  add  a
              prefix to entries.  See -pa for more.

       -t mmddyyyy
       --from-date mmddyyyy
              Do  not  operate  on files modified prior to the specified date,
              where mm is the month (01-12),  dd  is  the  day  of  the  month
              (01-31),  and  yyyy  is  the  year.   The  ISO 8601  date format
              yyyy-mm-dd is also accepted.  For example:

                     zip -rt 12071991 infamy foo

                     zip -rt 1991-12-07 infamy foo

              will add all the files in foo and its subdirectories  that  were
              last  modified  on  or after 7 December 1991, to the zip archive
              infamy.zip.

              Both -t and -tt can be used together to  set  a  date  range  to
              include files between two dates.

              In  zip  3.1  and later, times can be included to further refine
              the date/time filtering.  Times are specified in the formats

                     :hh:mm

                     :hh:mm:ss

              where hh is the hour (24 hour format from 00 to 23), mm  is  the
              minute  (00  to 59), and ss is the second (00 to 59).  Note that
              times in a zip archive are in MSDOS format and have about 2 sec-
              ond resolution.

              The  leading  colon  (:) is required for a time.  If the date is
              left off, the current date is assumed.

              For example, the above examples including a time of 8  AM  would
              be:

                     zip -rt 12071991:08:00 infamy foo

                     zip -rt 1991-12-07:08:00 infamy foo

              When  using  times,  make sure to account for time zone and day-
              light saving time changes between where entries were  added  and
              where they are being listed or extracted.

       -tt mmddyyyy
       --before-date mmddyyyy
              Do not operate on files modified after or at the specified date,
              where mm is the month (01-12),  dd  is  the  day  of  the  month
              (01-31),  and  yyyy  is  the  year.   The  ISO 8601  date format
              yyyy-mm-dd is also accepted.  For example:

                     zip -rtt 11301995 infamy foo

                     zip -rtt 1995-11-30 infamy foo

              will add all the files in foo and its subdirectories  that  were
              last  modified  before  30  November  1995,  to  the zip archive
              infamy.zip.

              See -t for how times are handled.

       -T
       --test
              Test the integrity of the new zip file. If the check fails,  the
              old  zip  file  is  unchanged  and (with the -m option) no input
              files are removed.

              The -T option actually spawns a command like "unzip  -tqq  temp-
              name"  to test the temporary archive (where tempname is replaced
              by zip with the path to the  temporary  archive  being  tested).
              Usually  this  uses  the  default  unzip on the system.  If this
              isn't compatible with the archive being created (such as when  a
              5  GB  archive  is being created and the system has an old unzip
              that can't test it), either unzip should be updated  or  -TU  or
              -TT used to specify what unzip to use for testing.

              If  multiple  unzip programs are installed on the system, it may
              be useful to change the (Unix) PATH or (VMS) symbol DCL$PATH  so
              that "unzip" runs the right program.

              As  of zip 3.1, any password given to zip is no longer passed to
              unzip unless -pu is  used.   This  generally  results  in  unzip
              prompting  for the password, which is usually safer than includ-
              ing the password on the command line used to  execute  unzip  to
              perform the testing (as that command line may be visible to oth-
              ers).  Adding -pu to the command line restores passing the pass-
              word to unzip.

              As -T passes the password on the command line, passwords includ-
              ing more than basic 7-bit printable ASCII characters  may  fail.
              Also,  zip  uses various escapes to attempt to pass shell-recog-
              nized characters on the command line for instance, but this  can
              fail in some situations.  It's generally safer (and more secure)
              to not use  -pu  and  just  enter  the  password  manually  when
              prompted by unzip.

              If  other  than  the  system  default unzip needs to be used for
              testing, use -TU instead of -TT  when  possible.   -TU  provides
              full  unzip  functionality,  such  as  detailed error reporting,
              while any utility can be specified in the -TT command string and
              so zip provides only minimal support.

              When  -TT  is  not being used, including -TV on the command line
              will tell unzip to be more verbose,  providing  the  results  of
              each  file test.  As of zip 3.1, the -v option is no longer used
              for this purpose.

              In previous versions of zip, the archive was  created  and  then
              unzip called to test the archive.  If unzip did not have a capa-
              bility needed to test the archive, the  test  would  fail.   The
              archive  may  be  fine, but the test failing may negate the cre-
              ation of a large archive that may have no issues.  As  the  test
              was  done after the archive was created, possibly hours might go
              by before the unzip incompatibility was found.

              zip 3.1 now gathers the features unzip would need  to  test  the
              archive  after  the  file scan but before the zip operation pro-
              ceeds, and compares that list of features to the features of the
              unzip  being  used  for  the testing.  If the unzip is missing a
              needed feature, zip 3.1 will  exit  with  an  error  before  the
              archive  is created, noting the needed but missing features.  If
              unzip passes this check, the odds are good that  if  an  archive
              test  fails it is because of a bad archive rather than an incom-
              patible unzip.  (At this point  zip  is  rather  stable  and  we
              believe  it  unlikely it would create a bad archive, unless some
              outside factor prevents it from doing so, and in these cases zip
              generally reports the problem and exits with an error.)  If this
              check fails, consider creating the archive without -T  and  then
              testing the resulting archive using unzip.

              zip  3.1  now  splits  the  ZE_TEST error code into two distinct
              error codes.  Now the new error ZE_UNZIP is returned  if  either
              unzip  (or whatever program is used with -TT) can't be found, is
              not executable, or is incompatible  with  the  planned  archive.
              ZE_TEST  now  is reserved for when an archive fails testing or a
              related testing issue occurs.

              As of zip 3.1 the temp file is tested if the created archive  is
              a  single  disk  archive  and --out is not used.  If the created
              archive is multi-disk (split), the output needs to be renamed to
              the  final  name  for  unzip to find all the parts, so the final
              archive is generated and that is tested.  If --out is used,  the
              results  of  the archive test will not impact the input archive,
              so the output archive is renamed to the final output name before
              the  archive  is  tested.  So if the output is split or --out is
              used, there's only limited benefit using -T to test the  archive
              rather  than  finishing the archiving operation and then testing
              the archive using unzip -t.  However, operations  like  -m  that
              remove files are still aborted if the test fails.

       -TT cmd
       --unzip-command cmd
       --test-command cmd
              Use  command cmd instead of 'unzip -tqq' to test an archive when
              -T is used.

              Where as this option can use any utility to do the testing,  -TU
              always  uses  unzip.  As -TU provides better unzip support, that
              is preferred for testing over -TT.

              On Unix, to use a copy of unzip in the current directory instead
              of the standard system unzip one could use:

               zip archive file1 file2 -T -TT "./unzip -tqq"

              In  cmd,  {}  is  replaced by the name of the temporary archive,
              otherwise the name of the archive is appended to the end of  the
              command.   If  a  password was provided to zip, the first {p} in
              the cmd string is replaced by the password.  (See  the  password
              warning  for  -T.)  The return code is checked for success (0 on
              Unix).

              unzip 3.1 introduces additional string formats that can be  used
              in  a -TT string.  "{p: -P {p}}" only inserts "-P password" into
              the string if a password is being passed from zip.   This  fixes
              the  issue  where  adding  {p}  to the command string required a
              password to always be passed or the {p} would remain.

              Keyfiles are supported using  {k},  which  inserts  the  keyfile
              path,  and "{k: -kf {k}}", which acts similar to the conditional
              password inclusion above.

              The string {y} is also available, which passes the entire key on
              the  command  line,  but  this should only be used for debugging
              purposes and may not handle passwords with binary  keyfile  con-
              tent.

              For  example  (where  unziplarge  might  be a copy of unzip 6 or
              later with large file support):

                     zip -T -TT "unziplarge -tqq" big_archive.zip

                     zip -T -TT '/usr/local/bin/unzip6 -tqq' big_archive.zip

              Note that -TT specifies the whole unzip command  (including  the
              -t and -qq options), not simply the unzip program itself.  Care-
              lessness here can cause "zip  -T"  to  extract  files  from  the
              archive instead of merely testing it.  This is one reason -TU is
              safer, as -TU takes care of the command details for you.

              -TT can be used with other programs to do the testing, not  just
              unzip.   However, the -TT option must specify a complete command
              line to use the other program.  Also, the return code  needs  to
              be compatible with what zip expects.

              In  general,  use -TU unless a program other than unzip is being
              used.

       -TU unzippath
       --unzip-path unzippath
              Test using unzip as normal, but use unzippath as  the  unzip  to
              test  with.   Unlike  -TT, -TU only specifies the path to unzip.
              Specifying a password and/or a keyfile is automatically  handled
              by  zip.   Also,  as unzip must be used with -TU, zip is able to
              provide detailed interpretation of unzip errors, while -TT  only
              returns error numbers.

              On Unix, to use a copy of unzip in the current directory instead
              of the standard system unzip, one could use:

               zip archive file1 file2 -T -TU ./unzip

              Note that only the unzip path is specified.

              As less can go wrong with -TU than -TT, use of  -TU  instead  of
              -TT is highly recommended.

       -TV
       --unzip-verbose
              When  using  unzip  to  test, adding -TV to the zip command line
              removes the "qq" from the command line used  to  execute  unzip,
              resulting  in  the  test results of each file being shown.  This
              can help determine what issues exist in an  archive  that  fails
              testing.

              -TV  replaces  using -v to show the testing details of each file
              in the archive.

              -TV can't be used with -TT.

       -u
       --update
              Replace (update) an existing entry in the zip archive only if it
              has  been modified more recently than the version already in the
              zip archive.  For example:

                     zip -u stuff *

              will add any new files in the current directory, and update  any
              files  which  have been modified since the zip archive stuff.zip
              was last created/modified (note that zip will not  try  to  pack
              stuff.zip into itself when you do this).

              Note  that  the -u option with no input file arguments acts like
              the -f (freshen) option.

              -u will not catch if a file is replaced with an older  one.   If
              all  changes  to  a directory need to be accounted for, consider
              using -FS (file sync) instead.

              -u can be impacted if entries were added  under  different  time
              zones.  See -f for more on time zones.

       -U
       --copy-entries
              Copy  entries  from  one archive to another.  Requires the --out
              option to  specify  a  different  output  file  than  the  input
              archive.  Copy mode is the reverse of -d delete.  When delete is
              being used with --out, the selected entries are deleted from the
              archive  and  all  other  entries are copied to the new archive,
              while copy mode selects the files to include in the new archive.
              Unlike -u update, input patterns on the command line are matched
              against archive entries only and not the file system files.  For
              instance,

                     zip inarchive "*.c" --copy --out outarchive

              copies  entries  with  names  ending in .c from inarchive.zip to
              outarchive.zip.  The wildcard must be escaped on some systems to
              prevent the shell from substituting names of files from the file
              system which may  have  no  relevance  to  the  entries  in  the
              archive.

              If  no input files appear on the command line and --out is used,
              copy mode is assumed:

                     zip inarchive --out outarchive

              This is useful for changing split size for instance  (by  adding
              the  -s  option).  It also will remove any data descriptors that
              are not needed.

              Encrypting and decrypting entries is  not  yet  supported  using
              copy mode.  Use zipcloak for that.

       -UN v
       --unicode v
              Determine  what  zip should do with Unicode file names.  zip 3.0
              and later saves the UTF-8 translation of the path if  the  entry
              path is not entirely 7-bit ASCII.

              The  problem with using the standard path is this path is in the
              local character set of the zip that created the entry, which may
              contain characters that are not valid in the character set being
              used by the unzip.  When zip is reading an archive, if an  entry
              also  has a Unicode path, zip now defaults to using that Unicode
              path to recreate the standard path using the current local char-
              acter set.

              (Archive  entries  that  are "UTF-8 native" store only the UTF-8
              path.  The mismatch feature of this option is only applicable to
              entries stored as "local" instead of "UTF-8 native".  As of 3.1,
              zip defaults to storing entries as "UTF-8 native".)

              This option can be used to determine what zip should do if there
              is  a  mismatch  between the stored standard path and the stored
              UTF-8 path (which can happen if the standard path was  updated).
              In  all  cases,  if  there  is a mismatch it is assumed that the
              standard path is more current and zip uses that.  Values  for  v
              are:

                     q - quit if paths do not match

                     w - warn, continue with standard path

                     i - ignore, continue with standard path

                     n - no Unicode, do not use Unicode paths

              The default is to warn and continue.

              Characters  that  are not valid in the current character set are
              escaped as #Uxxxx and #Lxxxxxx, where x is  an  ASCII  character
              for a hex digit.  The first is used if a 16-bit character number
              is sufficient to represent the Unicode character and the  second
              if  the  character needs more than 16 bits to represent its Uni-
              code character code.  zip 3.0  would  attempt  to  transliterate
              (find  a close match for) characters that were not in the desti-
              nation character set.  The utility of this  has  been  marginal,
              however,  and  transliteration has been dropped in zip 3.1.  Now
              any characters not in the destination character set are replaced
              by  Unicode escapes.  This allows one-for-one deterministic con-
              version between paths with UTF-8 characters and paths with  Uni-
              code escapes.

              Setting -UN to

                     e - escape

              as in

                     zip archive -sU -UN=e

              forces zip to escape all characters that are not printable 7-bit
              ASCII.  (In zip 3.1 this is the default.)  The value for -UN can
              be  spelled  out or abbreviated, and multiple -UN options can be
              used:

                     zip archive -r foo -UN=ign -UN=escape -UN=local

              zip 3.0 defaulted to storing UTF-8 directly in the name and com-
              ment  fields on systems where UTF-8 is the current character set
              and storing UTF-8 in the new extra fields otherwise.  As of  zip
              3.1, the default is for zip to store UTF-8 as native in the name
              and comment fields, which is the default  for  most  major  zips
              now.  Setting -UN to LOCAL as in:

                     zip archive foo -r -UN=LOCAL

              reverts  back to storing UTF-8 in the extra fields and the local
              character set in the standard name  and  comment  fields.   When
              creating  an  archive  to be used with an old unzip, you can use
              this to ensure backward compatibility.

              Setting -UN to UTF8 as in:

                     zip archive foo -r -UN=UTF8

              reestablishes storing UTF-8 as native in the archive, overriding
              a  previous  -UN=LOCAL on the command line or set in an environ-
              ment variable.

              Note that Unicode paths can  be  quite  long.   On  Windows  the
              default  maximum  path  length is 260 bytes.  The new option -wl
              allows  storing  long  Windows  paths,  though  restoring   them
              requires support by the unzip.

              Also, some native support for UTF-8 is now included in Windows 7
              and later, though it appears to be sufficiently buggy to prevent
              easy use.

              In zip 3.1, -UN=ShowUTF8 passes UTF-8 paths directly to the con-
              sole/message stream.  (This is  the  default  on  systems  where
              UTF-8  is  native.)  This option allows display of UTF-8 on sys-
              tems where normally escapes would be seen.  This option  can  be
              used,  for  instance, to display some UTF-8 on Windows in a con-
              sole window with code page 65001 enabled.   Not  all  characters
              are  viewable  using  this  code  page,  however.   For example,
              Japanese and other Asian  characters  are  not  viewable  in  an
              English   console   window.    On   Windows   Vista  and  later,
              -UN=ShowUTF8 is now the default.

              Also see -lu for putting UTF-8 in a log file.

       -UT
       --utest
              Perform some quick Unicode tests.   These  tests  give  a  rough
              indication  of  Unicode  support on the current platform as com-
              piled into zip.

              This option is disabled by default and  may  be  dropped  before
              release.

       -v
       --verbose
              Verbose mode or print diagnostic version info.

              Normally, when applied to real operations, the -v option enables
              the display of a progress indicator during compression (see  -dd
              for  more  on  dots)  and requests verbose diagnostic info about
              zipfile structure oddities (--verbose).

              However, when -v is the only command line argument the --version
              command is executed instead.

                     zip -v

              The  long  option  form  --verbose  always  executes the verbose
              option.

              --verbose is being updated and currently is of limited use.  See
              -ds  for  more  on  the  progress  indicator and -sd for more on
              debugging information.

       -v
       --version
              When -v is the only command line argument, or  the  long  option
              form  --version  is  used, a diagnostic screen is printed.  This
              should now work even if stdout is redirected to a file, allowing
              easy  saving  of the information for sending with bug reports to
              Info-ZIP.  The version screen provides the  help  screen  header
              with  program  name, version, and release date, some pointers to
              the Info-ZIP home and distribution sites, and shows  information
              about the target environment (compiler type and version, OS ver-
              sion, compilation date and the enabled optional features used to
              create  the  zip  executable as well as some additional informa-
              tion).

              When -v is not the only option given, the --verbose  command  is
              executed instead.

       -vq
       --quick-version
              Output  a  quick version string and exit.  This can be used by a
              script to determine the version of zip.  For example:

                      zip -vq

              might result in:

                     Zip    3.1d-BETA    (2015-08-12)     (c)2015     Info-ZIP
                     http://info-zip.org

              where  zip 3.1d-BETA  is  the  version (in this case BETA 3.1d),
              version date is in yyyy-mm-dd format, followed by the  copyright
              and then a reference to the Info-ZIP site.

       -V
       --VMS-portable
              [VMS]  Save VMS file attributes.  (Files are  truncated at EOF.)
              When a -V archive is unpacked on a non-VMS  system,   some  file
              types  (notably  Stream_LF  text  files   and  pure binary files
              like fixed-512) should be extracted intact.  Indexed  files  and
              file  types  with embedded record sizes (notably variable-length
              record types) will probably be seen as corrupt elsewhere.

       -VV
       --VMS-specific
              [VMS] Save VMS file attributes, and  all allocated blocks  in  a
              file,   including  any  data beyond EOF.  Useful for moving ill-
              formed files  among   VMS  systems.    When  a  -VV  archive  is
              unpacked  on a non-VMS system, almost all files will appear cor-
              rupt.

       -w
       --VMS-versions
              [VMS] Include file version numbers in  the  archive  names.   By
              default,  version  numbers  are stripped from the archive names.
              That is, "[.d]a.b;3" is normally archived as "d/a.b",  but  with
              -w,  it would be archived as "d/a.b;3".  (This might be inconve-
              nient on a non-VMS system.  See also -ww, below.)

              Note that zip normally processes only the highest version  of  a
              file  (";0"),  but  an explicit version wildcard (like ";*") can
              override this.  -w is required if multiple versions  of  a  file
              are to be stored in an archive; otherwise, when the version num-
              bers are stripped off as the files are stored  in  the  archive,
              the  duplicate  names  would  cause  "cannot repeat names in zip
              file" errors.

              Also see -ww for storing version using "." instead of ";".

       -wl
       --windows-long-paths
              [WIN32] Windows platforms are  generally  limited  to  paths  no
              longer  than  260  characters.   -wl enables reading and storing
              paths longer than  this.   The  upper  limit  with  this  option
              enabled becomes roughly 32 KB.

              A compatible unzip is needed to extract long paths.  In particu-
              lar, an archive with long paths will be  seen  as  corrupted  by
              Windows  Explorer under Windows 7 and earlier (and possibly Win-
              dows 8).  Do not save long paths in an archive unless  you  know
              the unzip at the other end can read and extract them.

              zip issues a warning when the first Windows long path is encoun-
              tered and at the end  of  the  zip  operation.   If  an  archive
              without  long paths is needed, either exclude or remove the long
              paths, or don't use -wl.

              -wl is now enabled by default.  Use -wl- to disable storing Win-
              dows long paths.

       -ww
       --VMS-dot-versions
              [VMS]  Like -w, except that version numbers in archive names use
              a "." separator instead of the default ";".  That is,  with  -w,
              "[.d]a.b;3"  would  be  archived  as "d/a.b;3", but with -ww, it
              would be archived as "d/a.b.3".  (This might  be  less  inconve-
              nient on a non-VMS system.)

       -ws
       --wild-stop-dirs
              Wildcards match only at a directory level.  Normally zip handles
              paths as strings and given the paths

                     /foo/bar/dir/file1.c

                     /foo/bar/file2.c

              an input pattern such as

                     "/foo/bar/*"

              normally would match both paths, the * matching dir/file1.c  and
              file2.c.   Note  that in the first case a directory boundary (/)
              was crossed in the match.  With -ws, no directory bounds will be
              included  in  the  match,  making  wildcards local to a specific
              directory level.  So, with -ws enabled,  only  the  second  path
              would be matched.

              Note  that  *  specified  in -R patterns never crosses directory
              boundaries.

              When using -ws, use ** to match across directory boundaries as *
              does normally.

       -x files
       --exclude files
              Explicitly  exclude  files  that  match the specified files/file
              patterns, as in:

                     zip -r foo foo -x \*.o

              which will include the contents of foo in  foo.zip  but  exclude
              all  the  files  that end in .o.  The backslash avoids the shell
              filename substitution, so that the name matching is performed by
              zip at all directory levels.

              A  file pattern is just a file path and name (generally relative
              to the input root directory) with optional wildcards.

              If wildcards are not acting as expected,  check  that  they  are
              escaped  in the command line.  Adding -sc to the command line to
              have zip output the command line as zip sees it allows verifying
              if any wildcards are being expanded by the shell.

              Also possible:

                     zip -r foo foo -x@exclude.lst

              which will include the contents of directory foo in foo.zip, but
              exclude  all  files  that  match  patterns  in  the  text   file
              exclude.lst,   one   file/file   pattern   per   line.    (Here,
              @exclude.lst is a value of the -x option.  Do not  confuse  this
              with an argfile.)

              The long option forms of the above are

                     zip -r foo foo --exclude \*.o

              and

                     zip -r foo foo --exclude=@exclude.lst

              Multiple patterns can be specified, as in:

                     zip -r foo foo -x \*.o \*.c

              As  of zip 3.0, -x (and -i) allow file lists that end before the
              end of the command line.  The list is terminated with  an  argu-
              ment  that  is  a single "@", the next option, or the end of the
              line.  So the above example could be rewritten as:

                     zip foo foo -x \*.o \*.c @ -r

              where -x \*.o \*.c @ is the exclude list.  Alternatively:

                     zip foo foo -x "*.o" "*.c" @ -r

              If there is no space between -x and the pattern, just one  value
              is assumed (no list):

                     zip -r foo foo -x\*.o

              To avoid confusion, the "=" form of this should be used, or this
              single value form not used at all (use  just  the  list  version
              instead).

                     zip -r foo foo -x=\*.o

              See -i for more on include and exclude.

       -X
       --no-extra
              Do  not save extra file attributes (Extended Attributes on OS/2,
              uid/gid on Unix, etc.).  The zip format  uses  extra  fields  to
              include  additional  information  for  each  entry.   Some extra
              fields are specific  to  particular  systems  while  others  are
              applicable to all systems.  Normally when zip reads entries from
              an existing archive, it reads the extra fields it knows,  strips
              the  rest,  and adds the extra fields applicable to that system.
              With -X, zip strips all old fields and only includes the Unicode
              and  Zip64  extra fields (if needed).  Currently these two extra
              fields cannot be disabled.  (As of zip 3.1, UTF-8 native mode is
              used  by default, so the Unicode extra fields are no longer used
              (by default).  The Zip64 extra fields are still used, regardless
              of -X, if Zip64 extensions are needed.)

              Negating  this  option,  -X-,  includes  all  the  default extra
              fields, but also copies  over  any  unrecognized  extra  fields.
              This  could  be  useful  if the archive came from a utility that
              works with extra fields not known to zip and you plan to use the
              archive with that utility again.

       -y
       --symlinks
              For  UNIX and VMS (V8.3 and later), store symbolic links as such
              in the zip archive, instead of compressing and storing the  file
              referred  to  by  the  link.   This can avoid multiple copies of
              files being included in the archive as zip recurses  the  direc-
              tory  trees  and accesses files directly and by links.  However,
              this will exclude new contents only available through a symlink.

              [WIN32]   As  of  zip  3.1,  Windows symlinks are now supported.
              This includes file  symlinks  as  well  as  directory  symlinks.
              (Where  as  UNIX  systems  do  not  distinguish between file and
              directory symlinks, Windows does.)  Windows  symlinks  are  only
              supported  on Windows XP or later.  unzip 6.1 or later is needed
              to recognize, list, and restore Windows symlinks in an  archive,
              otherwise  they  will  be listed and restored as simple files or
              directories.  Sufficient privilege is required to  restore  Win-
              dows symlinks (such as Administrative access).

       -yy
       --mount-points
              [WIN32]   For Windows Vista and later, zip 3.1 now detects mount
              points and will generally follow most quietly.  An exception are
              mount  points to off-line storage, which zip will warn about and
              skip.  -yy disables following mount points on Windows,  limiting
              the  current  zip  operation to the current mounted drive.  -yy-
              (negated -yy) follows mount points as without -yy, but  includes
              mount  points that look like off-line storage as well (which may
              require operator intervention to mount the off-line storage).

              Unix mount points not yet supported.

              Storage of and restoring mount points not yet supported.

       -Y em
       --encryption-method em
              Set the encryption method.  Supported  methods  are  Traditional
              (also  called  ZipCrypto,  considered weak by current encryption
              standards), and WinZip-compatible AES (relatively strong encryp-
              tion) with various key lengths: AES128, AES192, and AES256.  AES
              encryption must be enabled at build time, and requires a compat-
              ible Info-ZIP AES kit.  The source kit for adding AES encryption
              to zip is available on the Info-ZIP sites  (see  README  in  the
              source  kit  for  more information), but is subject to US export
              law  regarding  strong  encryption.   An  unzipper  capable   of
              decrypting  WinZip  AES entries (such as unzip 6.1) is needed to
              extract AES-encrypted entries.  (zip AES encryption is  compati-
              ble with WinZip and 7-Zip, for example.)

              We  ship  AES  encryption  in  a  separate kit to better meet US
              export restrictions.  The base zip source kit does  not  include
              strong  encryption,  possibly  allowing  its  use  where  strong
              encryption is not allowed.

              When available, Traditional encryption is the default.   (It  is
              possible to compile in AES encryption and leave out Traditional,
              or leave out all encryption.)

              Minimum password lengths are as follows:

              EncryptionMethod     MinPassLength

              Traditional                1

              AES WG 128                16

              AES WG 192                20

              AES WG 256                24

              Password lengths should be much longer than this  to  match  the
              security  provided  by  the key lengths, preferrably approaching
              the length of the key used.  The less predictable  the  password
              the better.

              The  maximum  AES  password  length  is 128 bytes (characters if
              7-bit ASCII).  This limit is in part a result of  how  passwords
              are hashed.

              See -kf for how to use keyfiles to set binary passwords.

       -z
       --archive-comment
              Prompt for a multi-line comment for the entire zip archive.  The
              comment is ended by a line containing just a period, or  an  end
              of file condition (^D on Unix, ^Z on MSDOS, OS/2, and VMS).  The
              comment can be taken from a file:

                     zip -z foo < foowhat

              The archive comment is generally limited to about 32,765 charac-
              ters.   However,  most  unzips  don't handle multi-line zip file
              comments well, if at all.  Probably best to  keep  to  a  single
              line no longer than 80 characters.

              As  of  zip  3.1, when interacting with a terminal zip will show
              the current archive comment and allow keeping that or  replacing
              it with a new comment.

       -Z cm
       --compression-method cm
              Set  the default compression method.  Currently the main methods
              supported by zip are Store and Deflate; however, as of  zip  3.1
              all  of  the below methods are shipped in the zip source kit and
              are compiled in by the standard build.  (Some ports do not  sup-
              port all of the additional compression methods.  See INSTALL for
              details.)  So for a standard build compression method can be set
              to (these are case insensitive):

              Store  -  Setting  the compression method to Store forces zip to
              store entries with no compression.   This  is  generally  faster
              than compressing entries, but results in no space savings.  This
              is the same as using -0 (compression level zero).

              Deflate - This is the default method for zip.  If zip determines
              that  using  Store  will  result  in  a smaller entry than using
              Deflate, the entry will be stored instead.

              Bzip2 - If Bzip2 support is compiled in, this compression method
              also  becomes  available.   Bzip2  tends to compress some data a
              little better but generally takes longer than Deflate.

              LZMA - If LZMA support is compiled in, this  compression  method
              also  becomes available.  LZMA can provide better compression of
              some types of files than Deflate, with a minor time impact.

              PPMd - If PPMd support is compiled in, this  compression  method
              also  becomes available.  PPMd can provide better compression in
              many cases, but may take much longer than Deflate.

              Note:  We are considering adding  Deflate64  (Enhanced  Deflate)
              and XZ compression to zip shortly.

              Many  older  unzip programs do not support the newer compression
              methods, Bzip2  (method  12),  LZMA  (method  14),  and/or  PPMd
              (method  98), so test the unzip you will be using before relying
              on archives using these methods.

              All compression methods (except LZMA) will test compression of a
              file  and  switch to Store if the size grows instead of shrinks.
              This automatic switchover has not been implemented for LZMA  yet
              but is planned.

              For  example,  to  add bar.c to archive foo using Bzip2 compres-
              sion:

                     zip -Z bzip2 foo bar.c

              The compression method can be abbreviated:

                     zip -Zb foo bar.c

              As of zip 3.1 it is possible to control the  compression  method
              used  on  a particular type of file with finer granularity.  See
              -n and -0, -1, ..., -9 for details.

       -0, -1, -2, -3, -4, -5, -6, -7, -8, -9
              Regulate the speed of compression  using  the  specified  digit,
              where  -0  indicates  no compression (store all files), -1 indi-
              cates the fastest compression speed (less  compression)  and  -9
              indicates  the  slowest compression speed (optimal compression).
              The default compression level is -6.

              This setting controls compression level for all methods  (except
              Store).

              With  zip  3.1  it  is now possible to set a default compression
              level for a specific compression method by providing an optional
              method list.  The format is:

                     -Level=MethodList

              where  Level  is  a single digit from 1 to 9 and MethodList is a
              list of methods as would be provided to  -Z.   Multiple  methods
              can be specified, separated by colons (or semi-colons).

              For example:

                     zip -9=LZMA:PPMD

              will  use  compression  level  9 as the default when compression
              methods LZMA or PPMD are specified.  Note that associating meth-
              ods  with  compression levels does not set a compression method.
              The default compression method is Deflate unless changed  by  -Z
              or -n.

                     zip -9=LZMA:PPMD foo.zip -r . -5

              sets  the  default  compression  level to 9 when LZMA or PPMd is
              used, but as the actual method to  use  is  not  specified,  the
              default  method Deflate and the global compression level of 5 is
              used.

              See options -Z and -n for more on  setting  compression  methods
              and levels.

       -!
       --use-privileges
              [WIN32]  Use  privileges  (if  granted) to obtain all aspects of
              WinNT security.

       -@
       --names-stdin
              Take a list of input files from standard input.  Only one  file-
              name per line.

       -@@ filepath
       --names-file filepath
              Same  as  -@,  but  take  a  list  of input files from text file
              filepath.  Only one filename  per  line.   (Don't  confuse  this
              option with using an argfile.)

       @argfilepath
              Open text file argfilepath and read arguments separated by white
              space, replacing this argument with the read arguments.  This is
              not  an  option, but listed here for comparison with -@ and -@@.
              argfilepath is an argument file  (argfile).   No  space  can  be
              between @ and argfilepath.  See the subsection on Argument Files
              for more on argument files.

       -$
       --volume-label
              [MSDOS, OS/2, VMS, WIN32]  Include  the  volume  label  for  the
              drive/device  holding the first file to be added to the archive.
              If you want to include only the volume label  (or  to  take  the
              volume  label  from  a  specific drive/device other than the one
              containing the first file), use the drive/device name (including
              the terminating colon) as first file name, as in:

                     zip -$ foo a: c:bar               [MSDOS, ...]

                     zip -$ foo dka0: dkc0:[bar]*.*    [VMS]

EXAMPLES
       The simplest example:

              zip stuff *

       creates the archive stuff.zip (assuming it does not exist) and puts all
       the files in the current directory in it, in compressed form (the  .zip
       suffix  is  added automatically, unless the archive name contains a dot
       already; this allows the explicit specification of other suffixes).

       Because of the way the shell on Unix does filename substitution,  files
       starting with "." are not included; to include these as well:

              zip stuff .* *

       Even  this  will not include any subdirectories from the current direc-
       tory.

       To zip up an entire directory, the command:

              zip -r foo foo

       creates the archive foo.zip, containing all the files  and  directories
       in the directory foo that is contained within the current directory.

       You  may  want  to  make  a zip archive that contains the files in foo,
       without recording the directory name, foo.  You can use the  -j  option
       to leave off the paths, as in:

              zip -j foo foo/*

       If  you are short on disk space, you might not have enough room to hold
       both the  original  directory  and  the  corresponding  compressed  zip
       archive.   In  this case, you can create the archive in steps using the
       -m option.  If foo contains the subdirectories tom,  dick,  and  harry,
       you can:

              zip -rm foo foo/tom
              zip -rm foo foo/dick
              zip -rm foo foo/harry

       where  the  first  command creates foo.zip, and the next two add to it.
       At the completion of each zip command,  the  last  created  archive  is
       deleted,  making  room for the next zip command to function.  (But read
       up on the -m option, especially the potential risks, before using  it.)

       zip  allows  output  from a program to be piped in and compressed.  For
       example, to get a list of files in a directory tree and save it in com-
       pressed form in a zip archive:

              ls -lR foo | zip foo_ls -

       Normally  this  saves the content as the entry "-" in the archive.  -SI
       can be used to rename this:

              ls -lR foo | zip foo_ls - -SI ls_output.txt

       To get a list of .c and .h files that would be archived and  pipe  that
       list through less:

              zip foo -r .  -i "*.c" "*.h" @  -sf  |  less

       This  command  would  create/update  the archive foo.zip, recursing the
       current directory (-r .) and including only files that match  the  pat-
       terns  "*.c"  and "*.h" (-i "*.c" "*.h" @), which are quoted to prevent
       shell expansion of the "*", the list terminated by "@".   However,  the
       -sf  tells  zip to do the file scan, but just list the files that would
       have been operated on if -sf was not there.

       Both input and output streaming can be done at the same time:

              tar cf - . | zip | dd of=/dev/nrst0 obs=16k

       See the section above on streaming for more.

       -s allows you to create split archives that can be saved  on  removable
       media.  For instance,

              zip -s 2g -r split.zip foo

       creates  a  split archive of directory foo with splits no bigger than 2
       GB each.  If foo contained 5 GB  of  contents  and  the  contents  were
       stored  in  the split archive without compression (to make this example
       simple), this would create three splits, split.z01 at 2  GB,  split.z02
       at 2 GB, and split.zip at a little over 1 GB.

       zip  provides  various  ways to track progress.  A log of what zip does
       can also be made.  For instance

              zip foo -r foo  -dbdcds 1g  -lFlila

       would zip up the directory foo and put  the  contents  in  the  foo.zip
       archive.   zip  displays the bytes processed and bytes to go (-db), the
       entries processed and to go (-dc), and progress  dots  for  each  entry
       where  each  dot  represents 1 GiB bytes processed (-ds 1g).  (Progress
       dots avoid long periods of quiet while large entries are processed.)  A
       log  is opened with name foo.log (-lF), and log entries are appended to
       any existing log content (-la).  Entry processing details (such as  the
       names  of  entries  processed), as well as any warnings and errors, are
       included in the log (-li).

PATTERN MATCHING
       This section mostly applies only to Unix.  Watch this space for details
       on MSDOS and VMS operation.  However, the special wildcard characters *
       and [] below apply to at least MSDOS also.

       The Unix shells (sh, csh, bash, and others) normally do  filename  sub-
       stitution (also called "globbing") on command arguments.  Generally the
       special characters are:

       ?      match any single character

       *      match any number of characters (including none)

       []     match any character in the range indicated within  the  brackets
              (example:  [a-f], [0-9]).  This form of wildcard matching allows
              a user to specify a list of characters between  square  brackets
              and  if any of the characters match the expression matches.  For
              example:

                     zip archive *.[hc]

              would archive all files in the current directory that end in  .h
              or  .c.   (This  example  is  allowing the Unix shell to process
              wildcards, so the wildcards are not escaped or quoted.)

              Ranges of characters are supported:

                     zip archive [a-f]*

              would add to the archive all files  starting  with  "a"  through
              "f".

              Negation is also supported, where any character in that position
              not in the list matches.  Negation is supported by adding ! or ^
              to the beginning of the list:

                     zip archive *.[!o]

              matches files that don't end in ".o".

              On  Unix, when wildcards are escaped or quoted, zip performs the
              wildcard processing.  (-RE is needed for zip  to  recognize  and
              process  []  lists.)  A notable difference, though, is the shell
              generally only searches the current directory for matches, while
              zip can match within subdirectories depending on the command.

              The same examples should work on Windows.  For example:

                     zip -RE archive *.[!o]

              As  of  zip 3.0, on WIN32 [] matching needs to be turned on with
              the -RE option to avoid the confusion that names  with  [  or  ]
              have  caused.   As of zip 3.1, -RE is needed on all platforms to
              enable use of [] for character ranges.  This is only  needed  on
              Unix if the [] are escaped (not handled by the shell).

              Prior  to zip 3.1, on Unix zip only provides wildcard support of
              -i, -x and -R patterns, not of input files.  (Full wildcard sup-
              port is provided for internal modes such as delete and copy that
              match internal archive entries.)  The  idea  was  to  allow  the
              shell  to  provide that support on Unix.  (Full wildcard support
              is provided by zip on Windows.)  zip 3.1 now provides full  Unix
              wildcard  support  internally  when  wildcards  are escaped from
              shell processing.

       On Unix, when these characters are encountered (without  being  escaped
       with  a backslash or quotes), the shell will look for files relative to
       the current path that match the pattern, and replace the argument  with
       a list of the names that matched.

       The  zip  program can do the same matching on names that are in the zip
       archive being modified or, in the  case  of  the  -x  (exclude)  or  -i
       (include)  options,  on  the  list of files to be operated on, by using
       backslashes or quotes to tell the shell not to do the  name  expansion.
       In  general,  when zip encounters a name in the list of files to do, it
       first looks for the name in the file system.  If it finds it,  it  then
       adds  it  to the list of files to do.  If it does not find it, it looks
       for the name in the zip archive being modified (if  it  exists),  using
       the  pattern matching characters described above, if present.  For each
       match, it will add that name to the list  of  files  to  be  processed,
       unless  this  name  matches  one  given with the -x option, or does not
       match any name given with the -i option.

       The pattern matching includes the path, and so patterns like \*.o match
       names  that  end  in  ".o",  no  matter  what the path prefix is.  (The
       default is for zip to match * across directory boundaries.  See -ws for
       more  on  this.)   Note  that  the backslash must precede every special
       character (i.e. ?, *, [, and ] for Unix), or the entire  argument  must
       be  enclosed  in double quotes ("").  (Some systems also permit quoting
       using single quotes ('') as well as quoting just  the  special  charac-
       ters,  as in foo"*"bar.c, which matches all paths that start with "foo"
       and end with "bar.c".)  Follow the specific rules for the OS and  shell
       you are using.

       In  general, use backslashes or double quotes for paths that have wild-
       cards to make zip do the pattern matching for file  paths,  and  always
       for paths and strings that have spaces or wildcards for -i, -x, -R, -d,
       and -U and anywhere zip needs to process the wildcards.

   Filters
       The options -i, -x and -R are considered filters.  When used, zip first
       gathers  all  file  names referenced by the input files during the file
       scan, recursing into directories if requested as needed.  Then the fil-
       ters are applied to remove files from this list.  So, for:

              zip foo.zip -r bar -RE -i "*.[ch]"

       the  entire bar directory will be scanned, then any files not ending in
       .c or .h will be dropped.  If bar is large, this could take  awhile  to
       scan.   When  possible,  narrow  the scope of the input scan as much as
       possible to minimize what zip needs to look at to  speed  up  the  file
       scan.

LIBRARIES/API
       The  zip source can be used to build both static and dynamic libraries.
       On Unix a static library can be built using Makefile, and the resulting
       library  is  named  libizzip.a.   On  Windows  both  static and dynamic
       libraries  can  be  built,  these  libraries  having  names   such   as
       zip32_dll.dll.   The  source  kit  also  includes example programs that
       demonstrate using the static and dynamic libraries.

       The zip LIB and DLL libraries have evolved since zip 3.0.   As  of  zip
       3.1d  the  application  programming interface (API) seems stable and no
       changes are expected from this  beta  to  release,  unless  issues  are
       found.

       See ReadLibDll.txt in the zip source kit for more information.

ENVIRONMENT
       The  following  environment  variables  are  read  and  used  by zip as
       described.

       ZIPOPT
              Contains default options that will be  used  when  running  zip.
              The  contents of this environment variable will get added before
              any command line arguments.

       ZIP
              [Not on RISC OS and VMS] See ZIPOPT.

       Zip$Options
              [RISC OS] See ZIPOPT.

       Zip$Exts
              [RISC OS] Contains extensions separated by a : that  will  cause
              native  filenames  with  one  of  the specified extensions to be
              added to the zip file with basename and extension swapped.

       ZIP_OPTS
              [VMS] See ZIPOPT.

SEE ALSO
       bzip2(1), compress(1), gzip(1), shar(1), tar(1), unzip(1), zipcloak(1),
       zipnote(1), zipsplit(1)

DIAGNOSTICS
       The exit status (or error level) approximates the exit codes defined by
       PKWARE (where applicable) and takes on  the  following  values,  except
       under VMS:

              0      (OK)  Normal successful completion.

              2      (EOF)  Unexpected end of zipfile.

              3      (FORM)   A  generic  error  in  the  zipfile  format  was
                     detected.  Processing  may  have  completed  successfully
                     anyway;  some  broken zipfiles created by other archivers
                     have simple work-arounds.

              4      (MEM)  zip was unable to allocate memory for one or  more
                     buffers.

              5      (LOGIC)  Internal logic error.

              6      (BIG)   Entry  too  large  to be processed (such as input
                     files larger than 2 GB when not using Zip64 or trying  to
                     read  an existing archive that is too large) or entry too
                     large to be split with zipsplit.

              7      (NOTE)  Invalid comment format to zipnote.

              8      (TEST)  "zip -T" archive test failed.

              9      (ABORT)  The user aborted zip prematurely with  control-C
                     (or similar).  Also can be result of internal error.

              10     (TEMP)  zip encountered an error while using a temp file.

              11     (READ)  Read or seek error.

              12     (NONE)  zip has nothing to do.  This may be the result of
                     no files matching provided file list.

              13     (NAME)  Missing (name not matched) or empty zip file.

              14     (WRITE)  Error writing to a file.

              15     (CREAT)  zip was unable to create a file to write to.

              16     (PARMS)  Bad command line parameters.

              18     (OPEN)  zip could not open a specified file to read.

              19     (COMPILE)   Error  in compilation options.  For instance,
                     large file support was compiled in, but the OS  does  not
                     support it.

              20     (ZIP64)  Zip64 not supported.

              21     (CRYPT)   Encryption related error.  As of zip 3.1, pass-
                     word errors now also return this.

              22     (COMPRESS)  Compression error.  This is an error specific
                     to a compression method.

              23     (BACKUP)  Backup error.  An error specific to backup mode
                     (-BT).

              24     (DEPTH)  Recursion depth limit exceeded.   (E.g.  argfile
                     recursion.)

              25     (SPLIT)  Attempt to read unsupported split archive.

              26     (UNZIP)   When  testing  archive,  could not run unzip or
                     incompatible unzip.

       These error codes are also used by the utilities zipcloak, zipnote  and
       zipsplit.

       VMS  interprets  standard Unix (or PC) return values as other, scarier-
       looking things, so zip instead maps them into VMS-style  status  codes.
       In general, zip sets VMS Facility = 1955 (0x07A3), Code = 2 * Unix_sta-
       tus, and an appropriate Severity  (as  specified  in  ziperr.h).   More
       details   are   included   in   the  VMS-specific  documentation.   See
       [.vms]NOTES.TXT and [.vms]vms_msg_gen.c.

       In some cases, the actual error code returned depends on  various  fac-
       tors.  See below examples:

       -      When  deleting  from an archive (using -d), if none of the files
              to delete are found in the archive, error code  12  (nothing  to
              do)  is  returned.  However, if the archive is empty, error code
              13 (empty zip file) is returned instead.  (This is a change from
              zip 3.0, which always returned error code 12 in this case.)

       -      When freshening or updating an archive, if a file can't be found
              error code 12 is returned.  However, if the  archive  is  empty,
              error code 13 is returned.  (This is also a change from zip 3.0,
              which always returned error code 12.)

       -      When using backup mode (-BT), if an error involving  opening  or
              reading  files  is  encountered,  the  appropriate file error is
              returned (such as error code 18 if  a  file  can't  be  opened).
              However,  if  the  contents  of  the backup control file are not
              appropriate for the requested backup operation,  error  code  23
              (backup error) is returned.

       In  addition,  zip  issues  warning messages if non-fatal errors occur.
       Most do not impact the return code, but some do.

BUGS
       zip 2.x and later are not compatible with PKUNZIP 1.10. Use zip 1.1  to
       produce zip files which can be extracted by PKUNZIP 1.10.

       zip  files produced by zip 2.x and later must not be updated by zip 1.1
       or PKZIP 1.10, if they contain encrypted members or if they  have  been
       produced in a pipe or on a non-seekable device. The old versions of zip
       or PKZIP would create an archive with an  incorrect  format.   The  old
       versions  can  list  the contents of the zip file but cannot extract it
       anyway (because of the new compression algorithm).  If you do  not  use
       encryption  and  use  regular disk files, you do not have to care about
       this problem.

       On VMS, zip archives should have record format Stream_LF  or  Fixed-512
       (the  usual Unix-like formats).  It may be possible to convert archives
       with other formats using Rahul Dhesi's BILF program.  This  version  of
       zip  handles  some  of the conversion internally.  When using Kermit to
       transfer zip files from VMS to MSDOS, type "set  file  type  block"  on
       VMS.   When  transferring from MSDOS to VMS, type "set file type fixed"
       on VMS.  In both cases, type "set file type binary" on MSDOS.

       On some older VMS versions, zip may hang for file  specifications  that
       use DECnet syntax foo::*.*.

       On OS/2, zip cannot match some names, such as those including an excla-
       mation mark or a hash sign.  This is a bug in OS/2 itself:  the  32-bit
       DosFindFirst/Next  don't  find  such names.  Other programs such as GNU
       tar are also affected by this bug.

       Under OS/2, the amount of Extended Attributes displayed by DIR is  (for
       compatibility)  the  amount returned by the 16-bit version of DosQuery-
       PathInfo(). Otherwise OS/2 1.3 and 2.0 would report different EA  sizes
       when  DIRing  a  file.   However,  the structure layout returned by the
       32-bit DosQueryPathInfo() is a bit different,  it  uses  extra  padding
       bytes  and  link  pointers  (it's  a linked list) to have all fields on
       4-byte boundaries for portability to future RISC OS/2 versions.  There-
       fore  the value reported by zip (which uses this 32-bit-mode size) dif-
       fers from that reported by DIR.   zip  stores  the  32-bit  format  for
       portability, even the 16-bit MS-C-compiled version running on OS/2 1.3,
       so even this one shows the 32-bit-mode size.

AUTHORS
       Copyright (C) 1997-2015 Info-ZIP.

       Currently distributed under  the  Info-ZIP  license.   A  copy  of  the
       license  is  included  in  the zip source kit.  The license can also be
       found on the Info-ZIP web site (www.info-zip.org).

       Copyright (C) 1990-1997 Mark Adler, Richard B. Wales, Jean-loup Gailly,
       Onno  van  der Linden, Kai Uwe Rommel, Igor Mandrichenko, John Bush and
       Paul Kienitz.

       Original copyright:

       Permission is granted to any individual or institution to use, copy, or
       redistribute  this  software  so  long as all of the original files are
       included, that it is not sold  for  profit,  and  that  this  copyright
       notice is retained.

       LIKE  ANYTHING  ELSE  THAT'S FREE, ZIP AND ITS ASSOCIATED UTILITIES ARE
       PROVIDED AS IS AND COME WITH NO WARRANTY OF ANY KIND, EITHER  EXPRESSED
       OR  IMPLIED.  IN  NO EVENT WILL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
       DAMAGES RESULTING FROM THE USE OF THIS SOFTWARE.

       Please send bug reports and comments using the web page  at:  www.info-
       zip.org.   For  bug reports, please include the information on the ver-
       sion page of zip (zip -v), the machine and operating system in use, and
       as  much additional information as possible.  Bugs can also be reported
       via the Info-ZIP user forum using the link on the above web site.

ACKNOWLEDGEMENTS
       Thanks to R. P. Byrne for his Shrink.Pas program, which  inspired  this
       project,  and  from which the shrink algorithm was stolen; to Phil Katz
       for placing in the public domain the zip file format, compression  for-
       mat,  and  .ZIP  filename extension, and for accepting minor changes to
       the file format; to Steve Burg for clarifications on the  deflate  for-
       mat;  to Haruhiko Okumura and Leonid Broukhis for providing some useful
       ideas for the compression algorithm; to  Keith  Petersen,  Rich  Wales,
       Hunter Goatley and Mark Adler for providing a mailing list and ftp site
       for the Info-ZIP group to use; and most importantly,  to  the  Info-ZIP
       group  itself  (listed  in the file infozip.who) without whose tireless
       testing and bug-fixing efforts a portable zip would not have been  pos-
       sible.   Finally  we should thank (blame) the first Info-ZIP moderator,
       David Kirschbaum, for getting us into this mess  in  the  first  place.
       The  manual page was rewritten for Unix by R. P. C. Rodgers and updated
       by E. Gordon for zip 3.0 and zip 3.1.

Info-ZIP                    6 November 2015 (v3.1)                      ZIP(1)
